<!DOCTYPE html>
<head>
    <!-- Meta tags -->
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="author" content="ვასილ ნადირაძე"/>
    <meta name="description" content="Javascript-ის ცნობარი, განმარტებები, მაგალითები">
    <meta name="keywords"  content="Javascript,ცნობარი,ვებ-დეველოპმენტი,დეველოპმენტი,საიტი,საიტები" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="../../public/styles/style.css" >
    <style type="text/css">@font-face {font-family: "First Font"; src: url(../../public/fonts/first.ttf) format("truetype"); }</style>
    <!-- Title -->
    <title>Javascript ცნობარი</title>
</head>
<body >

  <BR>


  <BR>
  <div class="content">
      <dl class="faqs">


          <dt>1. რა არის Javascript ?</dt>
          <dd class='answer'>

              javascript შეიქმნა იმისათვის, რომ "გაეცოცხლებინათ" ანუ უფრო დინამიური გაეხადათ  HTML გვერდები.
              ამ ენას თავდაპირველად ეწოდებოდა <strong>LiveScript</strong>, მაგრამ  მაშინ, ისევე როგორც ახლა,
              ძალიან პოპულარული ენა იყო <strong>Java</strong> და მარკეტოლოგებმა  გადაწყვიტეს, რომ Java-სთან
              მისმსგავსებული დასახელება უფრო პოპულარულს გახდიდა ენას. ასე წარმოიშვა  სახელი javascript.
              ჩაფიქრებული იყო, რომ javascript ყოფილიყო java-ს შვილობილი ენა მაგრამ  მოვლენები სხვანაირად
              განვითარდა, javascript დაიხვეწა, განვითარდა და ჩამოყალიბდა დამოუკიდებელ  ენად, რომელსაც გაჩნია
              თავისი სპეციფიკაცია -  ECMAScript. <br><br>  ამა თუ იმ ენაზე დაწერილი პროგრამის შესრულების  ორი
              ვარიანტი არსებობს : <strong>კომპილაცია</strong>  და <strong>ინტერპრეტაცია . </strong>
              <ul>
                  <li>
                      კომპილაცია - არის პროცესი, როდესაც პროგრამის კოდი, სხვა პროგრამის სპეციალური ინსტრუმენტის -
                      <strong>კომპილატორის</strong> დახმარებით გადაიწერება პროცესორისათვის გასაგებ ენაში -
                      სამანქანო ენაში და ამის შემდეგ ხდება მისი შესრულება. <br><br>
                      <img src="images/compiler.png" style="max-width: 500px;display: block; margin:0px auto;"> <br>

                  </li>
                  <li>
                      ინტერპრეტაცია - არის პროცესი, როდესაც პროგრამის კოდი გადაეცემა <strong>ინტერპრეტატორს ,</strong>
                      რომელიც კოდში მითითებულ ინსტრუქციებს ასრულებს კოდის სამანქანო ენაზე გადათარმნის გარეშე.
                  </li>
              </ul>

              Javascript არის პროგრამირების ინტერპრეტატორული ენა, ანუ მის კოდს კომპილაცია არ ჭირდება. ის
              სერვერზე  გაშვებისას ავტომატურად სრულდება.<br><br>




          </dd>


          <dt>2. მონაცემთა ტიპები</dt>
          <dd class='answer'>
              სხვა ენების მსგავსად, Javascript - ის სცენარშიც მოქმედებები სრულდება გარკვეულ მონაცემებზე.
              მონაცემი შეიძლება იყოს სამი სახის: <strong>ცვლადი, მუდმივა (კონსტანტა), გამოსახულება.</strong>,
              <br><br><br>
              <i>კონსტანტა</i> - ეს არის მონაცემი, რომლის მნიშვნელობაც პროგრამის მუშაობის დროს არ იცვლება.<br><br>
              <i>ცვლადი</i> - ცვლადის მნიშვნელობა, კონსტანტისაგან განსხვავებით, ცვალებადია. მის უკან მოიაზრება
              მეხსიერების რაღაც კონკრეტული, სახელდებული მონაკვეთი.<br><br>
              <i>გამოსახულება</i> - გამოსახულება წარმოადგენს ჩანაწერს, რომელიც შეიძლება შეიცავდეს კონსტანტებს, ცვლადებს
              და აგრეთვე ოპერაციებს (არითმეტიკული, ლოგიკური და ა.შ). <br><br>
              <strong>კონსტანტის და ცვლადის სახელებს ეწოდება იდენტიფიკატორები.</strong> ცვლადების სახელდებისას
              აუცილებლად უნდა იქნეს გათვალისწინებული შემდეგი მოთხოვნები:
              <ul>
                  <li>
                      ცვლადის სახელის პირველი სიმბოლო აუცილებლად უნდა იყოს ლათინური ანბანის დიდი ან
                      პატარა ასო, ან ქვედა ტირე ან დოლარის ნიშანი;
                  </li>
                  <li>ცვლადის სახელში დაუშვებელია სასვენი ნიშნებისა და გამოტოვებული ადგილების გამოყენება;</li>
                  <li>ცვლადის სახელი მგრძნობიარეა სიმბოლოთა რეგისტრის მიმართ;</li>
                  <li>ცვლადის სახელში სიმბოლოთა რაოდენობა არ არის შეზღუდული.</li>
                  <li>
                      დაუშვებელია javascript - ის რეზერვირებული სიტყვების - მაგ: for, while და ა.შ -
                      ცვლადის სახელებად გამოყენება.
                  </li>
              </ul>


              <h2>მონაცემთა ტიპები</h2>
              <strong>რიცხვითი ტიპი</strong> - მთელი (4, 250, 2017) და მცოცავმძიმიანი (45.5, 10.2, 6,8)
              რიცხვების ერთობლიობა. მცოცავმძიმიანი რიცხვები შეიძლება ჩაიწეროს <strong>ექსპონენციალური</strong>
              ფორმით, ეს ფორმა მოხერხებულია ძალიან დიდი და ძალიან პატარა რიცხვების ჩაწერისას:
              <ul>
                  <li>1.33e-5 = 0.0000133 </li>
                  <li>1.33e+5 = 133000 </li>
              </ul>

              არსებობს სპეციალური რიცხვითი მნიშვნელობები infinity, NaN (მათ შესახებ ვისაუბრებთ მე-9-ე თავში)


              <br><br>

              <strong>ლოგიკური ტიპი</strong> - ამ ტიპის მონაცემმა შეიძლება მიიღოს მხოლოდ ორი მნიშვნელობა
              true და false ანუ ჭეშმარიტი და მცდარი. მაგალითად 3<5 ჩანაწერი ჭეშმარიტია, 5>8 ჩანაწერი მცდარი.<br><br>

              <strong>სტრიქონული ტიპი</strong> - ზოგიერთ პროგრამირების ენაში არის მონაცემთა სპეციალური ტიპი
              ერთი სიმბოლოსათვის (მაგალითად C-ში არის ტიპი char). javascript-ში არსებობს მხოლოდ ტიპი
              <strong>string</strong> ანუ სტრიქონული ტიპი.  (უფრო დაწვრილებით ვისაუბრებთ მე-7-ე თავში)

              <br><br>

              <strong>მნიშვნელობა NULL</strong> - ამ მნიშვნელობას არანაირი კავშირი არ აქვს ზემოთ ჩამოთვლილ
              ტიპებთან, ეს არის ცალკე ტიპის ერთადერთი შესაძლო მნიშვნელობა, ანუ ეს არის სპეციალური მნიშვნელობა
              რომლის უკანაც იგულისხმება "არაფერი".
              <br><br>

              <strong>მნიშვნელობა UNDEFINED</strong> - მნიშვნელობა undefined, ისევე როგორც, null არის თავისი
              საკუთარი ტიპის ერთადერთი მნიშვნელობა. თუ ცვლადი გამოცხადებულია მაგრამ მასში არაფერია ჩაწერილი
              მაშინ ამ ცვლადის მნიშვნელობა არის UNDEFINED. <br><br>

              მონაცემთა ტიპის დასადგენად გამოიყენება <strong>typeof</strong> მეთოდი.
              <code>
                  var a=5; <br>
                  var b="This is a string";<br>
                  var c=true;<br>
                  var d=null;<br>
                  var e;<br>
                  console.log(typeof a); // number<br>
                  console.log(typeof b); // string<br>
                  console.log(typeof c); // boolean<br>
                  console.log(typeof d); // object<br>
                  console.log(typeof e); // undefined<br>
              </code>
          </dd>

          <dt>3. ოპერაციები და ოპერატორები</dt>
          <dd class='answer'>
              პროგრამაში ნებისმიერი ქმედება სრულდება ოპერაციების ამა თუ იმ სიმრავლის დახმარებით, ოპერაციები
              ჩაწერილია გამოსახულებების საშუალებით. <strong>გამოსახულება შედგება ოპერანდებისაგან, ოპერაციის ნიშნებისაგან
              და მრგვალი ფრჩხილებისაგან. მაგალითად a+b-10 გამოსახულებაში სიდიდეები a და b და კონსტანტა 10
              არიან ოპერანდები,  ხოლო "+" და "-" ოპერაციის  ნიშნები .</strong>  ოპერანდების რაოდენობიდან
              გამომდინარე Javascript - ში ოპერაცია შეიძლება იყოს
              <ul>
                  <li><strong>უნარული </strong>- როდესაც ოპერაციაში მხიოლოდ ერთი ოპერანდია. მაგ: -a</li>
                  <li><strong>ბინარული </strong>- როდესაც ოპერაციაში ორი ოპერანდია  მაგ: a+b</li>
                  <li><strong>ტერნარული</strong> - სამი ოპერანდის კომბინაცია,  პირობითი გამოსახულებები, მაგ: "? :" ჩანაწერი</li>
              </ul>

              <strong> შინაარსობრივი თვალსაზრისით</strong> კი ოპერაციები შეიძლება დაიყოს შემდეგ სახეებად :
              <ul>
                  <li>არითმეტიკული ოპერაციები</li>
                  <li>შედარების ოპერაციები</li>
                  <li>სტრიქონული ოპერაციები</li>
                  <li>ლოგიკური ოპერაციები</li>
                  <li>ბიტური ოპერაციები</li>
                  <li>მინიჭების ოპერაციები</li>
                  <li>შერეული ოპერაციები</li>
              </ul>

              <strong>არითმეტიკულ ოპერაციებში</strong> იგულისხმება მიმატება , გამოკლება, გამრავლება, გაყოფა, ნაშთი,
              უნარული მინუსი<br><br>
              <img src="images/mathopes.jpg" style="max-width: 800px;"> <br><br>

              <h2>ინკრემენტ და დეკრემენტ ოპერაციები</h2>
              <strong>ინკრემენტ და დეკრემენტ ოპერაციები წარმოადგენენ უნარული ოპერაციების ნიმუშს</strong>
              პირველი უზრუნველყოფს ცვლადის მნიშვნელობის 1 - ით გაზრდას (i++ ან ++i), მეორე კი შემცირებას
              (i-- ან --i).<br>  <strong>უნდა აღინიშნოს რომ i++ da ++i (ისევე როგორც i-- და --i) ტოლფასი
              ჩანაწერები არ არიან . ცვლადთან მიმართებაში ამ ოპერატორების (++,--)  მდებარეობა განსაზღვრავს
              თავად ოპერაციის (გაზრდა/შემცირება) შესრულების მომენტს შემდეგი კანონზომიერების მიხედვით :</strong>
              <ul>
                  <li>
                      თუ ოპერაცია ჩაწერილია ოპერანდის წინ (++a ე.წ ინკრემენტის პრეფიქსული ფორმა), მაშინ გაზრდა
                      მოხდება მიმდინარე გამოსახულების შესრულებამდე. ანუ ცვლადი ჯერ გაიზრდება/შემცირდება და
                      ისე მიიღებს მონაწილეობას გამოსახულების შესრულებაში
                  </li>
                  <li>
                      თუ ოპერაცია ჩაწერილია ოპერანდის შემდეგ (a++ ე.წ ინკრემენტის პოსტფიქსული ფორმა), მაშინ გაზრდა
                      მოხდება მიმდინარე გამოსახულების შესრულების შემდეგ. ანუ ცვლადი გამოსახულებაში მონაწილეწობას
                      მიიღებს გაზრდამდელი/შემცირებამდელი მნიშნელობით და შემდეგ გაიზრდება/შემცირდება
                  </li>
              </ul>
              მაგალითად :
              <code>
                  i = 1; <br>
                  k = ++i;  <br>
                  ამ შემთხვევაში i - ც და k - ც მიიღებენ მნიშვნელობა 2 - ს
              </code>
              <code>
                  i = 1; <br>
                  k = i++;  <br>
                  ამ შემთხვევაში i გახდება 2 ხოლო k 1
              </code> <br>

              <strong>ინკრემენტ და დეკრემენტ ოპერაციებს პრიორიტეტი აქვთ სხვა ნებისმიერ ოპერაციებთან მიმართებაში
              ფაქტიურად ამა თუ იმ გამოსახულების შესრულებისას პირველ რიგში სრულდება ++/-- ისევ და ისევ იმ
              პირობით რომ ოპერანდის მიმართ მათ მდებარეობას აქვს გადამწყვეტი მნიშვნელობა . </strong><br>
              <code>
                  i = 3; <br>
                  k = i++*3;  <br>
                  ამ შემთხვევაში  k იქნება 9 - ის ტოლი
              </code>
              <code>
                  i = 3; <br>
                  k = ++i*3;  <br>
                  ამ შემთხვევაში  k იქნება 12 - ის ტოლი
              </code>

              <br><br>

              <h2>შედარების ოპერაციები </h2>

              ამ ოპერაციების საშუალებით ხდება სხვადასხვა ტიპის ცვლადების მნიშვნელობების შედარება. და მიიღება შედეგი
              true ან false. ტოლობითი ოპერაციები შირად გამოიყენება if  და while ოპერატორებთან ერთად.შეიძლება
              შეგვხვდეს შემთხვევები, როდესაც ერთმანეთს ვადარებთ სხვადასხვა ტიპის ცვლადებს. შედარების ოპერატორიდან
              გამომდინარე, შესაძლოა, მოხდეს ტიპების გარდაქმნა და შემდეგ შესრულდეს შედარების ოპერაცია.
              <ul>
                  <li>
                      თუ ერთი ოპერანდი რიცხვითი ტიპისაა, მეორე კი - ტექსტური, მაშინ JavaScript შეეცდება
                      ტექსტური ტიპის ოპერანდის რიცხვითში გარდაქმნას. თუ ტექსტური ტიპის ოპერანდი რიცხვითში
                      ვერ გარდაიქმნება, მაშინ შედარების ოპერაციის შედეგი იქნება false.
                  </li>
                  <li>
                      თუ ერთი ოპერანდი ბულის ტიპისაა, მეორე ოპერანდი კი ტექსტურია, JavaScript შეეცდება
                      ორივე ოპერნადის რიცხვით ფორმატში გარდაქმნას და შემდეგ შესრულდება შედარების ოპერაცია.
                      თუ ტექსტური ტიპის ოპერანდი ვერ გარდაიქმნა რიცხვითში, მაშინ შედარების ოპერაციის შედეგი
                      იქნება false.
                  </li>
                  <li>
                      თუ ერთი ოპერანდი რიცხვითი ტიპისაა, მეორე ოპერანდი კი ბულის ცვლადია, მაშინ JavaScript
                      შეეცდება ბულის ტიპის ოპერანდის რიცხვით ფორმატში გარდაქმნას: true მნიშვნელობა გარდაიქმნება
                      1-ად, ხოლო false - 0-ად და ამის შემდეგ შესრულდება შედარების ოპერაცია.
                  </li>
              </ul><br><br>
              <img src="images/toloba.jpg" style="max-width: 800px;"> <br><br>


              <h2>სტრიქონული ოპერაციები </h2>

              ძირითადი სტრიქონული ოპერაცია არის <strong>კონკატენაცია (ინგ. concatenation ანუ შეერთება</strong>) ,
              ეს ოპერაცია  ახდენს სტრიქონების გაერთიანებას არითმეტიკული მიმატების ნიშნის (+) საშუალებით.
              მაგ: "a"+"b" = "ab"

              ისეთი გამოსახულების შესრულების შედეგად, რომლის ერთი ოპერანდი მაინც ტექსტური ტიპისაა, მიიღება
              ყოველთვის ტექსტური სტრიქონი, თუმცა არსებობს გამონაკლისებიც:
              <ul>
                  <li><strong>თუ გამოსახულების პირველი ოპერანდი ტექსტური ტიპისაა, მაშინ ყველა დანარჩენი ოპერანდიც
                      გარდაიქმნება ტექსტურ ფორმატში.
                      </strong>
                  </li>
                  <li>
                      <strong>თუ გამოსახულების პირველი რამდენიმე ოპერანდი რიცხვითი ტიპისაა, ხოლო დანარჩენები
                      ტექსტურია, მაშინ ჯერ შეიკრიბება რიცხვითი ოპერანდები, ხოლო შემდეგ შეიკრიბება ტექსტურ
                      ოპერანდთან და შედეგი მიიღება ტექსტური ტიპის.
                      </strong>
                  </li>
              </ul>

              <code>
                   var a="6"; <br>
                   var b=7;<br>
                   var c=8;<br>
                   var d;<br>
                   var e;<br>
                   var f;<br>
                   var result;<br>
                   d=a+b+c; // 678<br>
                   e=b+c+a; // 156<br>
                   f=c+a+b; // 867<br>
                   result=d+e+f; // 678 156 867<br>
                   alert(result); <br>
              </code>

              ტექსტური ოპერანდების შედარების ალგორითმზე ვისაუბრებთ მე-7-ე თავში.




              <h2>ლოგიკური ოპერაციები </h2>

              ლოგიკური ოპერაციებია
              <ul>
                  <li><strong>კონიუნქცია</strong> - ლოგიკური "და" ანუ AND (&&)</li>
                  <li><strong>დიზუნქცია</strong> - ლოგიკური "ან" ანუ  OR (||)</li>
                  <li><strong>უარყოფა </strong>- ლოგიკური "უარყოფა" არა ანუ NOT (!)</li>
              </ul><br>

              <img src="images/logic.jpg" style="max-width: 800px;"> <br><br>

              <strong>პრიორიტეტების მიხედვით პირველია "!" , შემდეგ "&&" , შემდეგ "||". აგრეთვე უნდა აღინიშნოს რომ
              დიზუნქცია და კონიუნქცია მარცხნივასოცირებული ოპერაციებია ანუ (a && b && c) ნიშნავს (a && (b && c))</strong>


              <h2>მინიჭების ოპერაციები </h2>

              მინიჭების ოპერაციებიც (ისევე როგორც  ინკიმენტი/დეკრიმენტი) მიეკუთვნებიან უნარული ოპერაციების ტიპს. <br>
              <img src="images/minicheba.jpg" style="max-width: 800px;"> <br><br>

              <h2>სხვა ოპერაციები </h2>
              <strong>პირობითი გამოსახულება "?:" </strong><br>
              გამოსახულებაში მონაწილეობს 3 ოპერანდი და ამიტომ ოპერაცია არის ტერნარული.
              პირველი ოპერანდი ღებულობს true/false მნიშვნელობას, დანარჩენმა ორმა კი ნებისმიერი ტიპის მნიშვნელობა
              შეიძლება მიიღოს. თუ პირველი ოპერანდის მნიშვნელობაა true, ოპერატორი "?:" დააბრუნებს მეორე ოპერანდიდან
              გამოთვლილ მნიშვნელობას, თუ არადა მესამე ოპერანდიდან გამოთვლილს.
              <br><br> expression1 ? expression2 : expression3
              <br> ფორმულირება1 ? ფორმულირება2 : ფორმულირება3 <br><br>მაგ :
              <code>
                   var x = 30; <br>
                   var y = x > 25 ? x-5 : x+5; <br>
                   console.log(y); <br>
                   დაბრუნდება 25, იმიტომ რომ x>25 პირობა სრულდება, ე.ი y უნდა გახდეს  x-5.
              </code>




          </dd>

          <dt>4. ოპერატორი switch</dt>
          <dd class='answer'>
              ეს ოპერატორი შედგება გამოსახულებისაგან და ვარიანტების სიისაგან. <br><br>

              <img src="images/switch.jpg" style="max-width: 800px;"> <br><br>
              <code>
                    var test = "tring";  <br>
                    switch (test){ <br>
                      &nbsp  case null: <br>
                         &nbsp&nbsp&nbsp   alert ("null"); <br>
                      &nbsp  break; <br>

                       &nbsp case "string": <br>
                        &nbsp&nbsp&nbsp    alert ("string"); <br>
                      &nbsp  break; <br>

                      &nbsp  case "ffffff": <br>
                      &nbsp&nbsp &nbsp     alert ("ffff"); <br>
                      &nbsp  break; <br>

                      &nbsp  default: alert ("arcerti"); <br>
                    }
              </code>
              სიტყვა გასაღები <strong>switch</strong> კითხულობს ცვლადის მნიშვნელობას, სიტყვა გასაღები <strong>case</strong>
              საშუალებას იძლევა განიხილოს, ჩამოითვალოს ცვლადის სავარაუდო მნიშვნელობები და აგრეთვე შესაბამისი მოქმედებები.
              <strong>break</strong> კი უზრულვეფოფს ციკლის დამთავრებას იმ შემთხვევაში თუ მის მშობელ case - ში
              მითითებული პირობა შესრულდება.  <strong>default</strong> არის ალტერნატიული ქწმედება თუ არც ერთ case - ში
              მითითებული პირობა არ სრულდება.


          </dd>

          <dt>5. ციკლის ინსტრუქციები </dt>
          <dd class='answer'>
              ამა თუ იმ ამოცანის გადასაჭრელად ხშირად საჭირო ხდება ერთი და იგივე გამოთვლების მრავალჯერ ჩატარება.
              <strong>განმეორებად ბრძანებათა ჯგუფს ეწოდება ციკლი</strong>. javascript - ში  ციკლები  იწერება
              შემდეგი ოპერატორების დახმარებით : <strong>while, do-while, for .</strong>

              <h2>ოპერატორი While </h2>
              while ციკლი არის ასე ვთქვათ წინაპირობითი, პრეპირობითი ანუ ციკლში პირობის შემოწმება/შესრულება ხდება
              ციკლის გამოძახებამდე , ანუ ციკლის ტანის შესრულებამდე გამოითვლება ლოგიკური პირობის მნიშვნელობა,
              თუ პირობა ჭერშმარიტია მაშინ ციკლიც სრულდება, ამის შემდეგ ისევ მოწმდება პირობა, ციკლი მეორდება
              მანამ სანამ პირობა არის true. მაგალითად განვიხილოთ  რიცხვის ფაქტორიალის გამოსათვლელი სკრიპტი
              (4! = 1 * 2 * 3 *4 = 24)<br><br>

              <code>

                  var i = 4; <br>
                  var k = 1;  <br>
                  var faqt = 1;  <br>
                  while(k <= i){  <br>
                    &nbsp;&nbsp; faqt *= k;  <br>
                    &nbsp;&nbsp;  k++;  <br>
                  }  <br>
                  console.log(faqt);  <br><br>


              </code>
              while ოპერატორის გამოყენება ხელსაყრელია მაშინ, როდესაც ცნობილი არაა თუ რამდენჯერ უნდა გამეორდეს ციკლი.


              <h2>ოპერატორი do-while </h2>
              do-while ციკლი while - საგან განსხვავეიბით არის პოსტპირობითი ანუ ციკლის გაგრძელების ლოგიკური
              პირობა იწერება ციკლის ტანის შემდეგ. სიტყვა გასარებ "do" - ს შემდეგ მინიმუმ ერთხელ სრულდება წიკლის
              ტანში აღწერილი მოქმედება და ამის შემდეგ მოწმდება ციკლის გაგრძელების პირობა, თუ იგი ჭეშმარიტია
              ანუ true, მაშინ ციკლი კიდევ სრულდება.
              <code>

                  var i = 4; <br>
                  var k = 1;  <br>
                  var faqt = 1;  <br>
                  do{  <br>
                    &nbsp;&nbsp; faqt *= k;  <br>
                    &nbsp;&nbsp;  k++;  <br>
                  }  <br>
                  while(k <= i);<br>
                  console.log(faqt);  <br><br>


              </code>

              <h2>ოპერატორი for </h2>
              ციკლის ეს ოპერატორი თავი თავში მოიცავს ცვლადს, ე.წ  <strong>ციკლის პარამეტრს</strong> ან
              <strong>ციკლის მთვლელს</strong>. ციკლი იწყება სიტყვა გასარებით <strong>for</strong>
              შემდეგ ფრჩხილებში იწერება კონსტრუქცია, რომელიც მოიცავს ციკლის პარამეტრის ინიციალიზაციას,
              ლოგიკურ გამოსახულებას და ამ პარამეტრის მოდიფიკაციის ანუ ცვლილების ჩანაწერს
              <code>

                  var faqt = 1; <br>
                  for (i=1;i<=4;i++){<br>
                    &nbsp;&nbsp; faqt*=i;<br>
                  }
                  console.log(faqt);<br>

              </code>

              <h2>ოპერატორი for-in </h2>
              ეს ოპერატორი ხელსაყრელია მასივებთან და ობიექტებთან მუშაობის დროს. მისი კონსტრუქცია ასეთია:
              <code>
                   for (variable in object) {series}
              </code>
              variable არის ცვლადი - მასივის ელემენტი ან ობიექტის თვისება. მაგალითად გვინდა <strong>ობიექტ navigator - ის
              თვისებების ნახვა (ეს ობიექტი მოიცავს ბრაუზერის შესახებ ინფორმაციას)</strong> უნდა დავწეროთ ასეთი რამ
              <code>
                   for(k in navigator){ <br>
                     &nbsp;&nbsp; document.write(k+"="+navigator[k]);<br>
                   }
              </code>

              <h2>ციკლის შეწყვეტა </h2>
              ციკლის შეწყვეტა შესაძლებელია ოპერატორ <strong>break</strong> - ის საშუალებით, რომელიც ჩართულია ციკლის ტანში.
              ის გამოიყენება მაშინ როდესაც ციკლის შესრულებისას დაფიქსირდება რაღაც შეცდომა ან იმშემთხვევაში
              როდესაც ცვლადი მიიღებს რაღაც კონკრეტულ მნიშვნელობას და აღარაა საჭირო ციკლის გაგრძელება.
              როგორც წესი break სრულდება რაიმე წინაპირობასთან ერთად.
              <code>

                  var i = 0; <br>
                  while (true){<br>
                 &nbsp;&nbsp; document.write(i);<br>
                 &nbsp;&nbsp; if(i == 9) break;<br>
                 &nbsp;&nbsp; i++;<br>
                  }
              </code>
              while (true) ციკლი უსასრულოა მაგრამ როდესაც i გახდება 9 - ის ტოლი ციკლი შეწყდება.

              <h2>ციკლის კონკრეტული იტერაციის შეწყვეტა </h2>
              დავუშვათ გვინდა არა მთლიანი ციკლის შეჩერება არამედ მისი კონკრეტული იტერაციის გაუქმება.
              ამ შემთხვევაში გამოიყენება ოპერატორი <strong>continue</strong>, რომელიც ციკლის ტანში იწერება. მაგალითად გვინდა
              1 დან 100 - მდე ისეთი ნატურალური რიცხვების ჯამის დათვლა რომლებიც უნაშთოდ იყოფა 5 - ზე.
              <code>
                  var sum = 0; <br>
                  for(i=1;i<=99;i++){ <br>
                     &nbsp;&nbsp;   if(i%5 == 0) continue; <br>
                    &nbsp;&nbsp;    sum+=i; <br>
                  } <br>
                  document.write(sum);
              </code>

          </dd>

          <dt>6. დიალოგური ფანჯრები alert,confirm, prompt, showModalDialog </dt>
          <dd class='answer'>
              <strong>alert, prompt, confirm არიან გლობალური ობიექტის  - "window" - ის მეთოდები . </strong> <br><br>

              <strong>alert</strong> არის დიალოგური ფანჯარა კონკრეტული წინადადებითა და "ok" ღილაკით, იგი ხშირად გამოიყენება
              იმ შემთხვევაში როცა გვსურს დავრწმუნდეთ რომ ესა თუ ის ინფორმაცია ნამდვილად მივიდა მომხმარებლამდე,
              იმდენად რამდენადაც მომხმარებელს "ok" ღილაკზე დაჭერამდე მიმდინარე ფანჯრის შიგთავსის ხილვის
              საშუალება არ ეძლევა. <br><br>
              <img src="images/alert.jpg" style="max-width: 800px;"> <br><br>

              <strong>confirm</strong>  არის დიალოგური ფანჯარა კონკრეტული წინადადებით და "ok" და "cancel"
              ღილაკებით. <strong>"ok" ღილაკზე დაჭერისას აბრუნებს მნიშვნელობას true, ხოლო "cancel" - ზე
              დაჭერისას მნიშვნელობას false .</strong><br><br>
              <img src="images/confirm.jpg" style="max-width: 800px;"> <br><br>

              <strong>prompt</strong> არის დიალოგური ფანჯარა რომელიც მომხმარებელს სთავაზობს ტექსტურ ველს და
              "ok" და "cancel" ღილაკებს. იგი ხშირად გამოიყენება მაშინ როდესაც გვსურს რომ მომხმარებელმა აკრიფოს
              რაიმე ინფორმაცია გვერდზე შესვლამდე. <strong>"cancel" - ზე დაჭერისას აბრუნებს მნიშვნელობას null, ხოლო
              "ok" - ზე დაჭერისას იმას რაც ველში აიკრიფება.</strong> <br><br>
              <img src="images/prompt.jpg" style="max-width: 800px;"> <br><br>
              prompt - ს შეიძლება მიეთითოს პარამეტრი რომელიც  ტექსტური ველის აღწერას უზრუნველყოფს (დავუშვათ გვინდა
              რომ შეყვანილი ინფორმაცია 20 სიმბოლოზე მეტი არ იყოს )

              <code>
                  confirm = prompt("მიუთითეთ ელ_ფოსტა","არაუმეტეს 20 სიმბოლო");
              </code> შედეგი იქნება
              <br><br>
              <img src="images/prompt1.jpg" style="max-width: 800px;"> <br><br>


          </dd>

          <dt>7. მუშაობა სტრიქონებთან</dt>
          <dd class='answer'>

              ჯავასკრიპტში ნებისმიერი ტექსტური მონაცემი ითვლება სტრიქონულ ტიპად - string, ამ ენაში არ არსებობს
              ცალკე ტიპი "სიმბოლო" (მაგალითად C-ის ანალოგია char) რომელიმე ცალკეული სიმბოლოსათვის .<br>
              სტრიქონის შესაქმნელად გამოიყენება ორმაგი ან ერთმაგი ბრჭყალები

              <code>
                  var string = "hello world"; <br>
                  var string = 'hello world'; <br>
              </code>

              <h2>სპეციალური სიმბოლოები</h2>

              სტრიქონი შეიძლება შეიცავდეს სპეციალურ სიმბოლოებს, ყველაზე ხშირად გამოიყენება ახალ ხაზზე
              გადასვლის სიმბოლო - "\n"

              <code>
                  alert( 'hello\nworld' ); // სიტყვა "world"-ს გამოიტანს ახალ ხაზზე
              </code><br><br>


              <h1>ობიექტი string, მისი მეთოდები და თვისებები</h1>


              <h2>length</h2>
              სტრიქონის სიგრძის გასაგებად გამოიყენება length მეთოდი.
              <code>
                  var string = "My\n"; // 3 სიმბოლო. მესამე - ახალი ხაზის სიმბოლო <br>
                  alert(string.length ); // 3
              </code>


              <h2>წვდომა სტრიქონის კონკრეტული ელემენტთან</h2>

              სტრიქონში კონკრეტული სიმბოლოს საპოვნელად გამოიყენება <strong>charAt მეთოდი.</strong>
              <code>
                   var string = "hello world, this is a string"; <br>
                   console.log(string.charAt(6)); // w
              </code>
              აბრუნებს პარამეტრად მითითებული რიცვის ტოლი ინდექსის შესაბამის სიმბოლოს. სიმბოლოზე წვდომისათვის
              შეიძლება გამოვიყენოთ კვადრატული ფრჩხილებიც.
              <code>
                  var string = "hello world"; <br>
                  alert(string[1]); // e
              </code>
              განსხვავება ამ ორ მეთოდს შორის არის ის, რომ თუ სტრიქონი არ შეიცავს პარამეტრად მითითებული
              რიცხვის ტოლ ინდექსიან სიმბოლოს charAt აბრუნებს ცარიელ სტრიქონს ხოლო ფიგურული ფრჩხილები
              undefined-ს.

              <strong>უნდა აღინიშნოს, რომ str.length – ეს არის სტრიქონის <label>თვისება</label>, ხოლო
              str.charAt(pos) –  სტრიქონის <label>მეთოდი, ანუ ფუნქცია.</label> მეთოდებთან მიმართვა
              ხდება ფრჩხილების საშუალებით ხოლო თვისებებთან-ფრჩხილების გარეშე.</strong>


              <h2>სტრიქონიდან მონაკვეთის ამოჭრა</h2>

              <h2>substr(start, length)</h2>
              ამოჭრას იწყებს პირველი პარამეტრის ტოლი ინდექსიდან და ჭრის იმდენ სიმბოლოს რა რიცხვიც
              მეორე პარამეტრად აქვს მითითებული.
              <code>
                    var string = "hello world, this is a string";<br>
                    console.log(string.substr(6,5)); // world
              </code>

              <h2>substring(start, end)</h2>
              ამოჭრას იწყებს პირველი პარამეტრის ტოლი ინდექსიდან და ჭრის მეორე პარამეტრად მითითებულ
              ინდექსა<label>მდე</label>, მეორე პარამეტრის ინდექსიანი სიმბოლო არ შედის ამოჭრილ მონაკვეთში
              <code>
                    var string = "hello world, this is a string";<br>
                    console.log(string.substring(6,8)); // wo
              </code>
              თუ substring(start, end)-ის პარამეტრი start მეტია პარამეტრ end-ზე, მაშინ ამოჭრა ხდება ისე
              თითქოს მათ ადგილები ჰქონდეთ გაცვლილი.<br></br>

              substring-ის მსგავსი მეთოდია slice-ც, განსხვავება მათ შორის ისაა, რომ სხვადასხვაგვარად აღიქვამენ
              უარყოფით პარამეტრებს
              <code>
                  alert( "testme".substring(-2) ); // "testme", -2 აღიქმება როგორც 0, ანუ დასაწყისი <br>
                  alert( "testme".slice(-2) ); // "me", ბოლოდან ორი პოზიცია
              </code>


              <h2>Unicode კოდირება</h2>

              როგორც ცნობილია სიმბოლოების შედარებისას ის სიმბოლოა მეტი რომელიც ანბანში უფრო ბოლოსკენ გვხვდება
              <code>
                  A < B < C < D < E < F < .... < Z
              </code>
              რატომ არის შემდეგი სკრიპტის შედეგი true ?
              <code>
                  alert("a" > "B"); //true
              </code>
              ან საერთოდ, რას ნიშნავს ერთი სიმბოლო მეტია მეორეზე ?  ამ საკითხებში გასარკვევად უნდა ვიცოდეთ თუ
              როგორ აღიქვამს ჯავასკრიპტი სიმბოლოებს: <strong>ყველა სიმბოლოს უკან იგულისხმება კოდირების სისტემა
              Unicode - ს რომელიღაც კოდი. Unicode ეს არის სიმბოლოების კოდირების სტანდარტი, რომელშიც
              წარმოდგენილია თითქმის ყველა დამწერლობის სიმბოლოები</strong> სინამდვილეშიც სიმბოლოები დარდება
              არა ანბანის მიხედვით, არამედ კოდების მიხედვით - ის სიმბოლოა მეტი, რომლის კოდიც მეტია, Unicode
              სტანდარტში კი პატარა ასოები გვხვდება დიდი ასოების შემდეგ, შესაბამისად პატარა ასოების კოდები მეტია
              დიდი ასოების კოდებზე, ამიტომაა "a" მეტი "B"-ზე<br><br>

              <strong>სტრიქონების შედარება ხდება ლექსიკოგრაფიულად, ანუ ცალ-ცალკე სიმბოლოების მიხედვით .
              მაგალითად s1 და s2 სტრიქონების შედარების ალგორითმი შემდეგნაირია</strong>

              <ol>
                  <li>
                      დარდება პირველი სიმბოლოები - s1[0] და s2[0]. თუ ისინი არ არიან ერთმანეთის ტოლნი
                      მაშინ ის სტრიქონია მეტი, რომლის პირველი სიმბოლოც მეტია.(მიუხედავად იმისა თუ რა ხდება
                      შემდეგ), ხოლო თუ პირველი სიმბოლოები ერთმანეთის ტოლია მაშინ ..
                  </li>
                  <li>
                      დარდება მეორე სიმბოლოები s1[1] და s2[1]
                  </li>
                  <li>
                      შემდეგ მესამეები Затем третьи s1[2] და s2[2] ა.შ. მანამ სანამ რომელმე სტრიქონის , რომელიმე
                      სიმბოლო არ იქნება მეორე სტრიქონის იგივე პოზიციაზე მდგომი სიმბოლოსაგან განსხვავებული. თუ
                      შედარებისას რომელიმე სტრიქონში ამოიწურა სიმბოლოები, მაშინ ითვლება, რომ ეს სტრიქონია ნაკლები,
                      ხოლო თუ ერთდროულად ორივეში ამოიწურა - მაშინ სტრიქონები ტოლები არიან.
                  </li>
              </ol>

              <strong>არის შემთხვევები, როდესაც რიცხვი სკრიპტში შედის სტრიქონის სახით, მაგალითად დიალოგური
              ფანჯრის - prompt-ის შედეგი. ასეთ შემთხვევაში ამ რიცხვების შედარების შედეგი იქნება არასწორი</strong>
              <code>
                   alert( "2" > "14" );  <br>
                   /*<br>
                     &nbsp;&nbsp; true, რადგანაც აღიქმება როგორც სტრიქონები, და პირველი სიმბოლოებიდან "2" > "1"<br>
                   */
              </code>

              <strong>თუ რომელიმე არგუმენტი არის რიცხვითი ტიპის მაშინ მეორეც გარდაიქმნება რიცხვით ტიპად</strong>
              <code>
                  alert( 2 > "14" ); // false
              </code>

              <strong>ECMA 402-ში ჩადებულია სტრიქონების შედარების მეთოდი str1.localeCompare(str2),
              რომელიც აბრუნებს -1-ს თუ str1 < str2, 1-ს თუ str1 > str2 და 0-ს თუ str1 = str2</strong>
              <strong>
                  var str = "hello"; <br>
                  alert( str.localeCompare("world") ); // -1
              </strong>



              <h2>fromCharCode()</h2>

              ობიექტ string-ს აქვს მეთოდი fromCharCode(), რომლის საშუალებითაც შეგვიძლია კოდის მიხედვით დავაბრუნოთ
              შესაბამისი სიმბოლო
              <code>
                  alert( String.fromCharCode(1072) ); // 'а'
              </code>
              აგრეთვე


              <h2>charCodeAt()</h2>
              ამ მეთოდის მეშვეობით შესაძლებელია კონკრეტულ ინდექსზე მდგომი რომელიმე ცვლადის Unicode
              ნომრის წაკითხვა და ბრაუზერის ფანჯარაში გამოტანა.
              <code>
                   var string = "hello world, this is a string";
                   console.log(string.charCodeAt(0)); // "h" - ს Unicode 104
              </code>

              დავწეროთ სკრიპტი, რომელიც გამოიტანს ქართული ანბანის ასოებს და მათ შესაბამის კოდებს
              <code>
                  str = "აჰ"; <br>
                  var first = str.charCodeAt(0); //4304<br>
                  var last = str.charCodeAt(1); //4336<br>
                  for(var i=first;i<=last;i++){<br>
                     &nbsp;&nbsp;&nbsp; document.write(String.fromCharCode(i) + " - " + i +"< br >");<br>
                  }<br>
              </code>




              <h2>concat</h2>
              ეს ოპერატორი მნიშვნელობით იგივეა რაც "+"
              <code>
                   var string = "hello world, this is a string"; <br>
                   console.log(string.concat(" text")); // hello world, this is a string text
              </code>

              <h2>indexOf</h2>
              ეს ოპერატორი სტრიქონში ეძებს პარამეტრად მითითებულ <strong>პირველ შემხვედრ</strong> სიმბოლოს
              და აბრუნებს მის ინდექსს. თუ მითითებული სიმბოლო საერთოდ არ არის ტექსტში მაშინ აბრუნებს -1 - ს
              <code>
                   var string = "hello world, this is a string"; <br>
                   console.log(string.indexOf("w")); // 6
              </code>

              <h2>lastIndexOf</h2>
              ეს ოპერატორი სტრიქონში ეძებს პარამეტრად მითითებულ <strong>ბოლო შემხვედრ</strong> სიმბოლოს
              და აბრუნებს მის ინდექსს.
              <code>
                    var string = "hello world, this is a string";<br>
                    console.log(string.lastIndexOf("l")); // 9;
              </code>

              <h2>split</h2>
              ეს ოპერატორი სტრიქონს აფორმატებს მასივად, მასივის ელემენტები კი არიან სტრიქონის ის მონაკვეთები
              რომლებიც სტრიქონში ერთმანეთისგან გამოიყოფიან split ოპერატორის პარამეტრად მითითებული სიმბოლოთი
              <code>
                    var string = "hello world, this is a string";<br>
                    console.log(string.split(",")); // ["hello world"," this is a string"]
              </code>
              თუ ეს პარამეტრი საერთოდ არ მიეთითება მაშინ მასივის ელემენტებში მოექცევა სტრიქონის სათითაო
              სიმბოლოები, ანუ ერთი ელემენტი იქნება ერთი სიმბოლო.




              <h2>replace</h2>
              ეს ოპერატორი სტრიქონში ეძებს პირველ პარამეტრად მითითებულ სიმბოლოს/სიტყვას და ანაცვლებს მას მეორე
              პარამეტრად მითითებული სიტყვით/სიმბოლოთი. <strong>თუ ეს სიტყვა სტრიქონში რამდენჯერმე მეორდება
              იცვლება მხოლოდ პირველი.</strong>
              <code>
                    var string = "hello world, this is a world";<br>
                    console.log(string.replace("world","tbilisi")); // hello tbilisi, this is a world
              </code>
              იმისათვის რომ ჩანაცვლებულ იქნას ყველა სიტყვა უნდა გამოვიყენოთ გლობალური მოდიფიკატორი
              <strong>(g)</strong>.
              <code>
                    var string = "hello world, this is a world";<br>
                    console.log(string.replace(/world/g,"tbilisi")); // hello tbilisi, this is a tbilisi
              </code>
              თავის მხრივ ამ მეთოდსაც აქვს ალტერნატივა, მაგალითად სტრიქონში "world" სიტყვა სამჯერ მეორდება
              მაგრამ პირველი იწყება დიდი ასოთი : "World", ამ შემთხვევაში (g) მოდერატორის ნაცვლად უნდა
              გამოვიყენოთ (gi) მოდერატორი
              <code>
                    var string = "hello World , world, this is a world"; <br>
                    console.log(string.replace(/world/gi,"tbilisi")); // hello tbilisi, tbilisi, this is a tbilisi
              </code>
              ახლა გამოვიყენოთ ფუნქცია ტექსტის ჩანაცვლებისათვის
              <code>
                    var str = "Mr Blue has a blue house and a blue car";
                    var res = str.replace(/blue|house|car/gi, function myFunction(x){return x.toUpperCase();});
                    // Mr BLUE has a BLUE HOUSE and a BLUE CAR.
              </code>


              <h2>toUpperCase და toLowerCase</h2>
              სტრიქონის ჩაწერა დიდ და პატარა ასოებად.
              <code>
                  alert( "hello".toUpperCase() ); // HELLO <br>
                  alert( "HELLO".toLowerCase() ); // hello
              </code>



          </dd>

          <dt>8. რეგულარული გამოსახულებები</dt>
          <dd class='answer'>

              <h2>რეგულარული გამოსახულებები ანუ იგივე Regular Expressions </h2>

              <strong>რეგულარული გამოსახულება არის სიმბოლოთა თანმიმდევრობა რომელიც ახდენს სტრიქონში ამა თუ
                  იმ სიმბოლოს ძებნისა ან ჩანაცვლების შაბლონის ფორმირებას. ჯავასკრიპტში რეგულარული გამოსახულებები
                  რეალიზებულია ცალკე ობიექტში RegExp.</strong> რეგულარული გამოსახულების შედგენის სინტაქსი ასეთია:
              <code>
                  var regexp = new RegExp("შაბლონი", "დროშა");
              </code>
              როგორც წესი გამოიყენება უფრო მოკლე ჩანაწერი :
              <code>
                  var regexp = /შაბლონი/; // დროშის გარეშე  <br>
                  var regexp = /შაბლონი/gmi; // gmi დროშებით (შევისწავლით ქვემოთ)
              </code>
              უმარტივეს შემთხვევაში, თუ დროშები და სპეციალური სიმბოლოები არ გვაქვს, შაბლონის მიხედვით ძებნა
              ეს იგივე რაც ჩვეულებრივი ძებნა სტრიქონში:
              <code>
                  var str = "მე მიყვარს ჯავასკრიპტი!"; // უნდა მოიძებნოს ამ სტრიქონში <br><br>

                  var regexp = /მი/;<br>
                  alert( str.search(regexp) ); // 3
              </code>
              შევადაროთ ჩვეულებრივ ძებნას :
              <code>
                  var str = "მე მიყვარს ჯავასკრიპტი!";<br><br>

                  var substr = "მე";<br>
                  alert( str.indexOf(substr) ); // 2<br>
              </code>
              როგორც ვხედავთ, ერთი და იგივეა, უბრალოდ რეგულარული გამოსახულება იყენებს მეთოდს search,
              ჩვეულებრივი ძებნა კი იყენებს მეთოდ – indexOf-ს.

              <h2>დროშები</h2>

              რეგულარულ გამოსახულებას შეიძლება გააჩნდეს ე.წ დროშები რომლებიც ზეგავლენას ახდენენ ძებნის შედეგებზე.
              დროშა შეიძლება შეგვხვდეს სამი სახის :
              <ul>
                  <li>
                      <strong>i</strong> -  ძებნა მიმდინარეობს რეგისტრის უგულებელყოფით, ანუ ერთნაირად
                      აღიქმება А და а (case-<label>i</label>nsensitive).
                  </li>
                  <li>
                      <strong>g</strong> - თუ ეს დროშა მითითებულია იძებნება/ნაცვლდება ყველა დამთხვევა,
                      წინააღმდეგ შემთხვევაში მხოლოდ პირველი (<label>g</label>lobal match).
                  </li>
                  <li>
                      <strong>m</strong> - მრავალხაზიანი ძებნა
                  </li>
              </ul>

              <code>
                  var str = "I Love JavaScript!";  <br><br>

                  alert( str.search( /LO/ ) ); // -1<br>
                  alert( str.search( /LO/i ) ); // 2<br>
              </code>
              ყოველივე ზემოთ თქმული რომ შევაჯამოთ მივიღებთ ასეთ რამეს:
              <ul>
                  <li>რეგულარული გამოსახულება შედგება შაბლონისაგან და არააუცილებელი დროშებისაგან g, i და m.</li>
                  <li>მეთოდი str.search(regexp) აბრუნებს ინდექსს, რომელზედაც დგას შესაბამისი დამთხვევა.</li>
              </ul>

              <h2>str.search(reg)</h2>

              ეს მეთოდი ზემოთ უკვე შეგვხვდა. ის აბრუნებს პირველი დამთხვევის პოზიციას ან -1-ს თუ დამთხვევა არ
              დაფიქსირდება.
              <code>
                  var str = "ეს ჯავასკრიპტია, ეს კარგი ენაა";<br>
                  alert( str.search( /ეს/i ) ); // 0
              </code>
              <strong>search მეთოდის შეზღუდვაც სწორედ ესაა – ის მხოლდ პირველ დამთხვევას ეძებს.</strong>


              <h2>r.match(reg) g დროშის გარეშე</h2>

              მეთოდი str.match მუშაობს სხვადასხვაგვარად, იმისდამიხედვით მივუთითებთ თუ არა დროშა g-ს. ჯერ
              განვიხილოთ შემთხვევა, როცა ის მითითებული არ არის. ამ შემთხვევაში str.match(reg) მხოლოდ პირველ
              დამთხვევას. ძებნის შედეგი - ეს არის მასივი, რომელშიც  მოთავსებულია ეს დამთხვევა და რომელსაც
              აქვს დამატებითი თვისებები : index - პოზიცია, რომელზეც მოხდა დამთხვევა და input –
              ანუ სტრიქონი რომელშიც მიმდინარეობდა ძებნა.
              <code>
                  var str = "GE-Ge-ge";<br><br>

                  var result = str.match( /ge/i );<br><br>

                  alert( result[0] ); // ge  (დამთხვევა)<br>
                  alert( result.index ); // 0 (პოზიცია)<br>
                  alert( result.input ); // GE-Ge-ge (მთლიანი სტრიქონი)<br>
              </code>
              ამ მასივს ყოველთვის ერთი ელემენტი არ აქვს. <strong>თუ შაბლონის ნაწილი მოთავსებულია ფრჩხილებში,
              მაშინ ეს ნაწილი ხდება მასივის ცალკე ეწლემენტი</strong>
              <code>
                  var str = "javascript - წარმატებისათვის";<br><br>

                  var result = str.match( /JAVA(SCRIPT)/i );<br><br>

                  alert( result[0] ); // javascript (მთლიანი დამთხვევა)<br>
                  alert( result[1] ); // script (დამთხვევის ფრჩხილებში მოთავსებული ნაწილი)<br>
                  alert( result.index ); // 0<br>
                  alert( result.input ); // javascript - წარმატებისათვის
              </code>

              <h2>r.match(reg) g დროშასთან ერთად</h2>

              დროშა g-სთან ერთად,  match აბრუნებს ყველა დამთხვევისაგან შემდგარ მასივს.
              <code>
                  var str = "GE-Ge-ge";<br>
                  var result = str.match( /ge/ig );<br>
                  alert( result ); // GE-Ge-ge <br>
              </code>
              <strong>იმ შემთხვევაში თუ დამთხვევა არ დაფიქსირდება , match აბრუნებს null-ს</strong>


              <h2>კლასები</h2>


              <strong>განსაზღვრული იერსახის სიმბოლოების საძებნელად რეგულარულ გამოსახულებებში განხილულია
              «სიმბოლოთა კლასები». სიმბოლოთა კლასი – ეს არის სპეციალური აღნიშნვა, რომელშიც მოთავსებულია
              ნებისმიერი სიმბოლო, სიმბოლოთა კონკრეტული ნაკრებიდან. </strong>. <br><br>
              მაგალითად კლასი «ნებისმიერი ციფრი». ის აღინიშნება ასე : \d. შემდეგ ეს აღნიშნვა ჯდება შაბლონში
              და ამგვარად ძებნაში ხვდება ნებისმიერი ციფრი.
              <code>
                  var str = "+995 571-17-33-11";  <br>
                  var reg = /\d/g;<br>
                  alert( str.match(reg) ); // ყველა დამთხვევის მასივი: 9,9,5,5,7,1,1,7,3,3,1,1<br>
              </code>
              რომ არ მიგვეთითებინა დროშა g, დაბრუნდებოდა მხოლოდ ციფრი 9.


              <h2> კლასები \d \s  და \w </h2>

              <ul>
                  <li>
                      <strong>
                          \d (ინგლისური სიტყვის «digit» – «ციფრი» პირველი ასო)
                      </strong>  - ციფრები, სიმბოლოები 0-დან 9-ის ჩათვლით
                  </li>
                  <li>
                      <strong>
                          \s (ინგლისური სიტყვის «space» – «ცარიელი ადგილი» პირველი ასო)
                      </strong> - ცარიელი სიმბოლოები, ტაბი, ხაზის გადატანა და ა.შ.
                  </li>
                  <li>
                      <strong>
                          \w (ინგლისური სიტყვის «word» – «სიტყვა» პირველი ასო)
                      </strong> - ლათინური ანბანის ასო ან ციფრი ან ქვედა ტირე '_'.  არალათინური ასოები არ
                      შედის \w კლასში.
                  </li>
              </ul>

              <h1>ნაკრები და დიაპაზონი [...]</h1>

              თუ რეგულარულ გამოსახულებაში რამოდენიმე სიმბოლო ან სიმბოლოთა კლასი მოქცეულია კვადრატულ
              ფრჩხილებში[…], ეს ნიშნავს რომ უნდა მოიძებნოს მითითებულ დიაპაზონში მოქცეული ნებისმიერი სიმბოლო.

              <h2>ნაკრები</h2>

              მაგალითად [еао] აღნიშნავს ამ სამი სიმბოლოდან ნებისმიერს: 'а', 'е', ან 'о'. ასეთ აღნიშნვას ეწოდება
              ნაკრები.
              <code>
                  // ვიპოვოთ [г или т], და შემდეგ "оп"  <br>
                  alert( "Гоп-стоп".match(/[гт]оп/gi) ); // "Гоп", "топ"
              </code>

              <h2>დიაპაზონი</h2>

              დიაპაზონებია მაგალითად: [a-z] – სიმბოლოები a-დან  z-ის ჩათვლით, [0-5] – ციფრები 0-დან 5-ის
              ჩათვლით.
              მოვძებნოთ დამთხვევა სადაც სიმბოლო "x"-ის შემდეგ მოდის ორჯერ ზედიზედ ან ნებისმიერი ციფრი ან
              ასოები A-დან  F-მდე:

              <code>
                  // მოძებნის "xAF" - ს <br>
                  alert( "Exception 0xAF".match(/x[0-9A-F][0-9A-F]/g) );
              </code>


              <h2>დიაპაზონი «გარდა»</h2>

              <strong>ჩვეულებრივი დიაპაზონების გარდა არსებობს გამონაკლისითი დიაპაზონები [^…].</strong>
              [^…] ამ დიაპაზონში მოქცეულია ნებისმიერი სიმბოლო გარდა მითითებულებისა. მაგალითად:
              <ul>
                  <li>[^аеуо] – ნებისმიერი სიმბოლო გარდა  'a', 'e', 'y', 'o'.</li>
                  <li>[^0-9] – ნებისმიერი სიმბოლო გარდა ციფრებისა ანუ იგივე \D.</li>
                  <li>[^\s] – ნებისმიერიარაცარიელი  სიმბოლო  ანუ იგივე \S.</li>
              </ul>
              <code>
                  alert( "alice15@gmail.com".match(/[^\d\sA-Z]/gi) ); // "@", "."
              </code>



          </dd>

          <dt>9. მუშაობა რიცხვებთან, მათემატიკური ოპერაციები </dt>
          <dd class='answer'>

              ჯავასკრიპტში, როგორც მთელი, ასევე ათწილადი რიცხვები ეკუთვნიან <strong>Number</strong>
              ტიპს და ინახებიან  IEEE-754 - ის 64 ბიტიან ფორმატში. IEEE იშიფრება, როგორც Institute of
              Electrical and Electronics Engineers და ნიშნავს ელექტრონიკის ინჟინერთა და ელექტრონიკის
              ინსტიტუტს, ხოლო IEEE-754 არის ამ ინსტიტუტში მიღებული, მცოცავმძიმიანი არითმეტიკის სტანდარტი.

              <h2>ნოლზე გაყოფა, Infinity </h2>

              დავსვათ კითხვა : რა  შეიძლება მოხდეს 0-ზე გაყოფისას ? როგორც წესი - შეცდომა პროგრამაში, ყოველ
              შემთხვევაში ეს ასეა პროგრამირების ენების უმრავლესობაში მაგრამ არა javascript-ში. როგორც ცნობილია რაც
              უფრო ნაკლებია გამყოფის მნიშვნელობა მით უფრო დიდია განაყოფი. ძალიან, ძალიან მცირე რიცხვზე გაყოფისას
              შედეგი იქნება ძალიან ძალიან დიდი. ამ ლოგიკიდან გამომდინარე javascript-ში 0-ზე გაყოფისას მიიღება
              უსასრულობა  ანუ +Infinity (-Infinity ანუ მინუს უსასრულობა. finite ნიშნავს სასრულს, ხოლო "In"
              არის უარყოფის წინსართი).<strong>  Infinity არის განსაკუთრებული რიცხვითი მნიშვნელობა, რომელიც
              თავის თავში გულისხმობს უსასრულობას</strong>
              <ul>
                  <li>Infinity არის ყველა რიცხვზე მეტი</li>
                  <li>უსასრულობაზე დამატება არ ცვლის მას</li>
              </ul>
              <code>
                  alert( Infinity > 1234567890 ); // true <br>
                  alert( Infinity + 5 == Infinity ); // true
              </code>

              <h2>NaN</h2>

              <strong>თუ ვერ ხერხდება მათემატიკური ოპერაციის შესრულება მაშინ მიიღება მნიშვნელობა NaN
              (Not-A-Number).</strong>ეს მნიშვნელობა გამოიყენება მათემატიკური შეცდომების "მოსანიშნად" და
              ახასიათებს შემდეგი თავისებურებები:
              <ul>
                  <li>
                      არ უდრის არაფერს თავის თავის ჩათვლით (?!), აი ეს კოდი არაფერს გამოიტანს
                      <code>
                          if (NaN == NaN) alert( "==" ); // არცერთი გამოძახება<br>
                          if (NaN === NaN) alert( "===" ); // არ იმუშავებს
                      </code>
                  </li>
                  <li>
                      მნიშვნელობა NaN შეიძლება შემოწმდეს სპეციალური ფუნქციით <strong>isNaN(n)</strong>,
                      რომელიც შეეცდება არგუმენტი  გარდაქმნას რიცხვად და  აბრუნებს true-ს თუ ეს არ გამოვიდა,
                      ყველა სხვა შემთხვევაში აბრუნებს false-ს
                      <code>
                          var n = 0 / 0; <br>
                          alert( isNaN(n) ); // true <br>
                          alert( isNaN("12") ); // false, სტრიქონი "12" გარდაიქმნა ჩვეულებრივ რიცხად 12 <br>
                      </code>
                  </li>
                  <li>
                      NaN-თან ნებისმიერი ოპერაციის შემდეგ ბრუნდება NaN.
                      <code>
                          alert( NaN + 1 ); // NaN
                      </code>
                  </li>
              </ul> <br> <br>


              <h2>isFinite(n)</h2>

              როგორც ვნახეთ ჯავასკრიპტში გარდა "ჩვეულებრივი" რიცხვებისა არის სპეციალური მნიშვნელობები
              NaN/+Infinity/-Infinity. იმისათვის რათა ეს "ჩვეულებრივი" რიცხვები განვასხვავოთ ამ სპეციალური
              მნიშვნელობებისაგან, გამოიყენება ფუნქცია isFinite. (პირდაპირი მნიშვნელობით "არის სასრული ?")
              <strong>ფუნქცია isFinite(n) გარდაქმნის არგუმენტს რიცხვად და აბრუნებს true, თუ შედეგი არ
              არის NaN/Infinity/-Infinity ამათგან ერთ-ერთი.</strong>

              <code>
                  alert( isFinite(1) ); // true <br>
                  alert( isFinite(Infinity) ); // false<br>
                  alert( isFinite(NaN) ); // false<br>
                  alert( isFinite("გჰფგჰფგფგჰ") ); // false
              </code><br>


              <h2>რიცხვად გარდაქმნა</h2>

              მათემატიკური ფუნქციებისა და არითმეტიკული ოპერაციების უმრავლესობა, ამა თუ იმ ტიპის მონაცემს
              ავტომატურად გარდაქმნის რიცხვად. მაგალითად

              <code>
                  var s = "12.34";<br>
                  alert( +s ); // 12.34
              </code>
              ამასთანავე თუ სტრიქონი არ გარდაიქმნება რიცხვად შედეგი იქნება Nan.
              <code>
                  alert( +"12test" ); // NaN
              </code>
              ერთადერთი გამონაკლისი არის სტრიქონში შემავალი ცარიელი სიმბოლოები, რომელთა იგნორირებაც ხდება
              რიცხვით ფორმატში გადაყვანისას
              <code>
                  alert( +"  -12" ); // -12 <br>
                  alert( +" \n34  \n" ); // 34, ხაზის გადატანა \n ითვლება ცარიელ სიმბოლოდ<br>
                  alert( +"" ); // 0, ცარიელი სტრიქონი  გარდაიქმნება 0-ად<br>
                  alert( +"1 2" ); // NaN, ცარიელი სიმბოლო რიცხვის შიგნით - შეცდომა<br>
              </code><br><br>


              <h2>parseInt(), parseFloat() </h2>

              HTML/CSS-ის სამყაროში მონაცემები ყოველთვის არ არის მკაფიოდ და აშკარად რიცხვითი ტიპის (მაგ: 12px).
              ამ მნიშვნელობისათვის "+" ოპერატორი, როგორც ზემოთ ვნახეთ დააბრუნებს NaN-ს. ასეთ შემთხვევებში
              გამოიყენება ფუნქციები parseInt() და parseFloat().

              <ul>
                  <li><strong>parseInt()</strong> - ტექსტის გარდაქმნა მთელ რიცხვად</li>
                  <li><strong>parseFloat()</strong> - ტექსტის გარდაქმნა მცოცავმძიმიან რიცხვად</li>
              </ul>

              <code>
                  alert( parseInt('12px') ); // 12
              </code>

              <strong>ფუნქცია parseInt და მისი ანალოგი parseFloat სტრიქონს გარდაქმნიან რიცხვად ნაბიჯ-ნაბიჯ
              ცალ-ცალკე სიომბოლოების მიხედვით, მანამ არ დაფიქსირდება შეცსომა.</strong>
              <code>
                  alert( parseInt('12px') ) // 12, შეცდომა სიმბოლო 'p' - ზე
                  alert( parseFloat('12.3.4') ) // 12.3, შეცდომა მეორე წერტილზე
              </code>

              რა თქმა უნდა არის შემთხვევები, როდესაც ეს ფუნქციებიც აბრუნებენ მნიშვნელობა NaN-ს.

              <code>
                  თუ parseInt() და parseFloat() ფუნქციების არგუმენტები არ იწყება რიცხვით მაშინ ისინი აბრუნებენ
                  მნიშვნელობას NaN, რადგან რიცხვის ძებნა იწყება არგუმენტის დასაწყისიდანვე დანარჩენი ნაწილი კი
                  უგულებელყოფილია.<br>
                  parseInt("12 საათია"); // 12<br>
                  parseInt("ახლა არის 12 საათი") // NaN<br>
                  parseFloat("0.5 ლიტრი ლუდი") // 0.5<br>
                  parseFloat("მომეცით 0.5 ლიტრი ლუდი") // NaN<br>
              </code><br><br>



              <h1>მათემატიკური ოპერაციები</h1>


              მათემატიკური ოპერაციებისათვის javascript - ში გამოიყენება ობიექტი <strong>Math</strong>,
              განვიხილოთ მისი მეთოდები.
              <code>
                  console.log(Math.abs(-5));  // 5  აბსოლიტური მნიშვნელობა ანუ მოდული<br><br>
                  console.log(Math.ceil(5.2)); // 6 რიცხვის დამრგვალება მარჯვნიდან უახლოაეს მთელ რიცხვამდე მიუხედავად ათწილადისა<br><br>
                  console.log(Math.floor(5.9)); // 5 რიცხვის დამრგვალება მარცხნიდან უახლოაეს მთელ რიცხვამდე მიუხედავად ათწილადისა<br><br>
                  console.log(Math.round(6.2)); // 6 ჩვეულებრივი დამრგვალება<br><br>
                  console.log(Math.PI); //  3.141592653589793<br><br>
                  console.log(Math.max(3,78,35,1)); //  მაქსიმუმი<br><br>
                  console.log(Math.min(3,78,35,1)); //  მინიმუმი<br><br>
                  console.log(Math.pow(3,3)); // 27  ახარისხება<br><br>
                  console.log(Math.random()); //  შემთხვევითი რიცხვი [0-1] შუალედიდან<br><br>
                  console.log(Math.sqrt(16)); // 4  ფესვი<br><br>
              </code><br><br>

              <h2>დამრგვალება მითითებულ სიზუსტემდე</h2>

              როგორც ცნობილია, მათემატიკაში არსებობს ასეთი ტერმინები "მეათედების სიზუსტემდე დამრგვალება",
              "მეასედების სიზუსტემდე დამრგვალება" და ა.შ. <strong>ათწილადის მძიმის მარჯვნივ სასურველ
              თანრიგამდე  დამრგვალებისათვის ეს ათწილადი უნდა გავამრავლოთ 10-ის იმ ხარისხზე, მძიმის მარჯვნივ
              რამდენი ერთეულის სიზუსტითაც ვამრგვალებთ, შემდეგ მიღებული შედეგი დავამრგვალოთ Math.round()-ით
              და ბოლოს ეს შედეგი გავამნრავლოთ 10-ის იმავე ხარისხზე.</strong> მაგ: მუდმივა PI = 3.1415926..
              დავამრგვალოთ მეასედების სიზუსტემდე

              <code>
                  var PI = 3.1415926; <br>
                  alert( Math.round(PI * 100) / 100 ); // 3.1415926 -> 314.15926 -> 314 -> 3.14
              </code><br><br>


              <h2>num.toFixed(precision)</h2>

              ეს მეთოდი ამრგვალებს რიცხვს მითითებულ სიზუსტემდე (precision ნიშნავს სიზუსტეს) და აბრუნებს
              შედეგს <strong>სტრიქონის სახით.</strong> დამრგვალება ხდება უახლოეს მთელ რიცხვამდე
              Math.round()-ის მსგავსად. (უნდა აღინიშნოს, რომ ამ მეთოდსაც აქვს თავისი უხერხული მხარეები
              რიცხვების ორობით სისტემაში გადაყვანისას, ამ უზუსტობებზე ქვემოთ ვისაუბრებთ)
              <code>
                   var PI = 3.1415926;<br>
                   alert(PI.toFixed(2)); // 3.14<br>
                   alert(typeof PI.toFixed(2)); // string<br>
              </code>

              თუ შედეგი აუცილებლად რიცხვითი ტიპისა გვინდა, რომ უყოს მაშინ, როგორც ზემოთ ვნახეთ, დაგვეხმარება
              არითმეტიკული ოპერაციის ნიშანი "+"

              <code>
                   var PI = 3.1415926;<br>
                   alert(PI.toFixed(2)); // 3.14<br>
                   alert(typeof +(PI.toFixed(2))); // number <br>
              </code>

              <h1>არაზუსტი გამოთვლები (!!!)</h1>

              გავუშვათ ასეთი სკრიპტი :
              <code>
                  alert( 0.1 + 0.2 == 0.3 ); // false  <br>
                  alert( 0.1 + 0.2 ); // 0.30000000000000004
              </code>

              შედეგები მართლაც უცნაურია... <strong>საქმე იმაშია, რომ როდესაც ჯავასკრიპტი ახდენს გამოთვლებს,
              იგი რიცხვებს გარდაქმნის ორობით სისტემაში და სწორედ აქ ჩნდება პრობლემა - 0.1 არ ფორმატდება
              ორობით სისტემაში აბსოლიტური სიზუსტით რადგან ორობით სისტემაში 1-ის 10-ზე გაყოფით მიიღება
              უსასრულო პეიოდი. </strong><br>
              ეს რა თქმა უნდა არ ნიშნავს იმას, რომ ასეთ რიცხვებზე ზუსტი ართმეტიკული ოპერაციების ჩატარება
              არ შეიძლება. ზუსტი გამოთვლების ჩასატარებლად არსებობს ორი ვარიანტი:
              <code>
                  alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
              </code>
              ან
              <code>
                  var result = 0.1 + 0.2; <br>
                  alert( +result.toFixed(10) ); // 0.3
              </code>

              <strong>უნდა აღინიშნოს, რომ სიზუსტესთან მიმართებაში ანალოგიურად ვითარდება მოვლენები პროგრამირების
              ყველა ენაში, რომლებიც იყენებენ IEEE 754-ს (C, PHP, Ruby, Perl)</strong>


          </dd>




          <dt>10. მასივები </dt>
          <dd class='answer'>
              <strong>მასივი არის ცვლადის ტიპი რომელშიც შეიძლება შეინახოს რამოდენიმე მნიშვნელობა ერთდროულად. სხვა
              სიტყვებით   მასივი ეს არის მონაცემთა ჩაწერის ტიპი რომელიც შედგება მონაცემთა დანომრილი ფრაგმენტებისაგან.
              ამ ფრაგმენტებს ეწოდება მასივის ელემენტები ხოლო ფრაგმენტების ნომრებს ამ ფრაგმენტების ინდექსები .<br><br>
              მასივი აგრეთვე შეიძლება განვიხილოთ, როგორც მნიშვნელობათა მოწესრიგებული ნაკრები.</strong><br><br>
              javascript - ში მასივის ელემენტები შეიძლება შეიცავდნენ სხვადასხვა ტიპის მონაცემებს, მაგ: ერთი შეიძლება
              იყოს მთელი, მეორე ათწილადი და ა.შ. აგრეთვე მასივებს ახასიათებთ დინამიურობა ანუ შეგვიძლია წავშალოთ
              რომელიმე ელემენტი  ან პირიქით დავამატოთ. <strong>მასივის ინდექსაცია იწყება 0 - დან.</strong>
              თუ მასივში არის ვთქვათ 5 ელემენტი  ამბობენ რომ  მასივის სიგრძე არის 5. განვიხილოთ მასივის შექმნის
              ვარიანტები:
              <code>
                  var array1 = [1,,2,5.6,"hello","world",true];
              </code>
              მასივის სიგრძის გამოსათვლელად გამოიყენება <strong>length</strong> სიტყვა გასაღები :
              <code>
                  console.log(array1.length);
              </code>
              როგორც ვხედავთ ამ მასივში სხვადასხვა ტიპის ინფორმაციაა შენახული. ელემენტებთან წვდომა ხდება შემდეგნაირად:
              მაგალითად დავაბრუნოთ მე-3-ე ელემენტი : array1['2']; როგორც ვხედავთ მასივის მეორე ელემენტი ცარიელია,
              თუ მას დავაბრუნებთ მივიღებთ მნიშვნელობას undefined. <br><br> მასივი შეიძლება შეიქმნას ასეც :
              <code>
                  var array1 = new Array[1,,2,5.6,"hello","world",true];
              </code>
              <strong>ამ ჩანაწერით ჩვენ გამოვიძახეთ ობიექტი Array - ს მეთოდი კონსტრუქტორი . </strong>

              <h2>ასოციაციური მასივები</h2>

              <strong> მასივის ინდექსი შეიძლება იყოს არამარტო ციფრი, არამედ მაგალითად სტრიქონული ტიპისაც.
              სახელდებული ინდექსების შემცველ მასივს ეწოდება ასოციაციური მასივი.
              ასოციაციური მასივი არის მონაცემთა სტრუქტურა, რომელშიც შეიძლება შევინახოთ ნებისმიერი ინფორმაცია
              გასაღები-მნიშვნელობა ფორმატში.</strong> ის შეიძლება შევადაროთ კარადას წარწერებიანი უჯრებით, მონაცემები
              ინახება ამ უჯრებში, დასახელების მიხედვით ადვილად ვპოულობთ საჭირო უჯრას და ვიღებთ იქიდან ინფორმაციას.
              <br> <br><img src="images/key.jpg" style="max-width: 800px;"> <br>

              <br><br>
              <code>
                  javascript - ში ასეთი მასივები არ გამოიყენება ! javascript მათ აღიქვამს როგორც ობიექტებს,
                  რის შემდეგაც მასივის ყველა ფუნქცია და მეთოდი არასწორ მნიშვნელობას დააბრუნებს.
                  მასივი არის ობიექტის ასე ვთქვათ ერთ-ერთი "სახეობა" , განსხვავება ობიექტსა და მასივს შორის არის
                  ის რომ ობიექტში გვაქვს სახელდებული ინდექსები მასივში  კი ნუმერირებული. როდის გამოვიყენოთ
                  მასივი და როდის ობიექტი ? იმის გათვალისწინებით რომ javascript ასოციაციურ მასივებს არ უჭერს
                  მხარს, ობიექტები უნდა გამოვიყენოთ მაშინ როდესაც ელემენტების ინდექსები გვინდა რომ იყოს ტექსტური ტიპისანი,
                  ხოლო თუ გვინდა რომ იყოს რიცხვითი ტიპისები მაშინ უნდა გამოვიყენოთ მასივი.

              </code>

              <h2>მასივის "დათვალიერება" , for in ინსტრუქცია</h2>
              დავუშვათ გვინდა მასივის ელემენტების მნიშვნელობებისა და ამ ელემენტების ინდექსების ნახვა. ამისათვის
              გამოიყენება for in ინსტრუქცია
              <code>
                   var array1 = [1,2,5.6,"hello","world",true];  <br>
                   for(var index in array1){ <br>
                      &nbsp;&nbsp;  console.log("ინდექსი - " + index + " მნიშვნელობა "  + array1[index]);<br>
                   }
              </code>

              <h2>მასივის მეთოდები</h2>
              <h2>Array.join()</h2>
              მასივის ელემენტების სტრიქონულ ტიპად ჩაწერა, იმ შემთხვევაში თუ
              join - ს პარამეტრად არაფერს მივუთიტებთ, ელემენტები ერთმანეთისგან გამოიყოფიან მძიმით.
              <code>
                   var array1 = [1,2,5.6,"hello","world",true];  <br>
                   document.write(array1.join()); // შედეგი : 1,2,5.6,hello,world,true
              </code>
              ხოლო თუ მივუთითებთ მაშინ ელემენტები გამოიყოფა მითითებული სიმბოლოთი:
              <code>
                   var array1 = [1,2,5.6,"hello","world",true];  <br>
                   document.write(array1.join("|")); // შედეგი : 1|2|5.6|hello|world|true
              </code>


              <h2>Array.reverse()</h2>  მასივს ალაგებს უკუთანმიმდევრობით (ახალ მასივს არ ქმნის):
              <code>
                   var array1 = [1,2,5.6,"hello","world",true];  <br>
                   document.write(array1.reverse()); // შედეგი : true,world,hello,5.6,2,1
              </code>

              <h2>Array.sort()</h2>
              მასივის ელემენტების ანბანის მიხედვით დალაგება (ახალ მასივს არ ქმნის). ციფრებსაც განიხილავს როგორც სტრიქონებს
              <code>
                   var array1 = [100,111,22,222,5,"hello","world",true];  <br>
                   document.write(array1.sort()); // შედეგი : 100,111,22,222,5,hello,true,world
              </code>

              <h2>Array.concat()</h2>
              მასივს ამატებს ელემენტებს ბოლოში.
              <code>
                   var array1 = [100,111,22,222,5,"hello","world",true];  <br>
                   document.write(array1.concat("false","javascript")); // შედეგი : 100,111,22,222,5,hello,world,true,false,javascript
              </code>

              <h2>Array.slice()</h2>
              მასივის ფრაგმენტის ამოღება, გადაეცემა ორი პარამეტრი: პირველი პარამეტრის მნიშვნელობის ინდექსიდან იწყებს
              ამოჭრას და მეორე პარამეტრის წინა ელემენტით ასრულებს, ანუ მეორე პარამეტრის ინდექსიანი ელემენტი არ შედის
              ამოჭრილ მასივში. თუ მხოლოდ ერთ პარამეტრს მივუთითებთ  მაშინ  ამოჭრის ამ პარამეტრიდან მასივის
              ბოლომდე. თუ უარყოფით მნიშვნელობებს მივუთითებთ  პარამეტრად მაშინ ბოლოდან ამოჭრის .
              <code>
                  var array1 = ["a","b","c","d","e","f"]; <br>
                  document.write(array1.slice(2,4)); // შედეგი : c,d<br>
                  document.write(array1.slice(2)); // შედეგი : c,d,e,f<br>
                  document.write(array1.slice(-2)); // შედეგი : e,f<br>
                  document.write(array1.slice(-3,-2)); // შედეგი : d<br>
              </code>


              <h2>Array.splice()</h2>
              მასაც ეთითება <strong>მინიმუმ</strong> ორი ელემენტი. პირველი უჩვენებს თუ მასივის რომელი ელემენტიდან
              დაიწყოს ამოჭრა, ხოლო მეორე უჩვენებს საწყისი ელემენტი<strong>დან</strong> რამდენი შემდეგი ელემენტი უნდა ამოიჭრას.
              ამის შემდეგ კი ქმნის ახალ მასივს რომელშიც თავსდება ამოჭრილი ელემენტები.
              <code>
                  var array1 = ["a","b","c","d","e","f"]; <br>
                  array1.splice(2,2); <br>
                  document.write(array1); // შედეგი : a,b,e,f<br>
              </code>
              splice - ს კიდევ შეიძლება მიეთითოს სხვა პარამეტრებიც, რომლებიც ამოჭრილი ელემენტების ნაცვლად ჩაჯდება
              საწყის მასივში.

              <code>
                 <strong>
                 განსხვავება slice - სა და splice - ს შორის ის არის,  slice ქმნის ახალ მასივს და ძველი იგივე რჩება,
                 ხოლო splice ახალ მასივსაც აბრუნებს და ამავე დროს პირველი მასივიც იცვლება ასე ვთქვათ "მუტაციას"
                 განიცდის და მისგან იჭრება მითითებული ელემენტები.
                 </strong>
              </code>

              <h2>Array.push()</h2>
              ახალი ელემენტების დამატება მასივის ბოლოში <strong>(ეს და ამის შემდეგ განხილული მეთოდებიც ცვლიან
              საწყის მასივს !!!) აბრუნებს ახალი მასივის სიგრძეს</strong>
              <code>
                  var array1 = ["a","b","c","d","e","f"]; <br>
                  array1.push(1,2,3); <br>
                  document.write(array1); // შედეგი : a,b,c,d,e,f,1,2,3<br>
              </code>

              <h2>Array.pop()</h2>
              მასივის ბოლო ელემენტის წაშლა <strong>(აბრუნებს წაშლილ ელემენტს)</strong>
              <code>
                  var array1 = ["a","b","c","d","e","f"]; <br>
                  array1.pop(); <br>
                  document.write(array1); // შედეგი : a,b,c,d,e<br>
              </code>

              <strong>ზუსტად ანალოგიური ფუნქციები მასივის დასაწყისთან მუშაობისათვის არის Array.unshift() და
              Array.shift(), პირველი ამატებს ელემენტებს და აბრუნებს ახალი მასივის სიგრძეს, მეორე შლის პირველ
              ელემენტს და აბრუნებს წაშლილ ელემენტს</strong>

              მასივის კონკრეტული ელემენტის <strong>მნიშვნელობის</strong> წასაშლელად გამოიყენება
              <strong>delete</strong>
              <code>
                  var array1 = ["a","b","c","d","e","f"]; <br>
                  delete.array1[2] <br>
                  document.write(array1); // შედეგი : a,b,,d,e,f,1,2<br>
              </code>
              ანუ თავად ელემენტი არ იშლება უბრალოდ მისი მნიშვნელობა ხდება <strong>undefined</strong>აქედან
              გამომდინარე არ იცვლება არც მასივის სიგრძე.
              <code>
                  document.write(array1[2]); // შედეგი : undefined
              </code>


              <h2>Array.isArray()</h2>
              იმის გასაგებად ცვლადში მოქცეულია თუ არა მასივი გამოიყენება Array.isArray().
              <code>
                  var array1 = ["a","b","c","d","e","f"]; <br>
                  var is =  Array.isArray(array1);<br>
                  console.log(is); // შედეგი true<br>
              </code>
              <code>
                  var age = 15; <br>
                  var is =  Array.isArray(age);<br>
                  console.log(is); // შედეგი false<br>
              </code>

              Array.isArray() - ს  რეალიზაცია მოხდა ES5 - ში.

              <code>
                  ECMAScript ანუ იგივე ES  არის ....
              </code><br><br>


              <h2>მრავალგანზომილებიანი მასივები</h2>
              როგორც ცნობილია javascript - ში მასივის ელემენტი შეიძლება იყოს ნებისმიერი ტიპის, მათ შორის შეიძლება იყოს
              ობიექტიც და აგრეთვე მასივიც. <strong>მრავლგანზომილებიანი მასივი ეს არის მასივი მასივში</strong>
              ასრთი მასივის ელემენტებთან წვდომისათვის გამოიყენება ორმაგი "[][]", მაგალითად array[i][j].

          </dd>





          <dt>11. ფუნქციები</dt>
          <dd class='answer'>
              <strong>
                  ფუნქცია ეს არის პროგრამის სახელდებული ფრაგმენტი, სხვადასხვა ინსტრუქციების ერთობლიობა. რომლის
                  განსაზღვრაც ხდება ერთხელ მაგრამ გამოძახება შეიძლება მრავალჯერ. ფუნქციის შექმნა ხდება შემდეგნაირად:
              </strong>
              <code>
                  function myFoo(){ <br>
                     // script<br>
                  }<br>
                  myFoo(); // ფუნქციის გამოძახება,  myFoo არის ფუნქციის სახელი ანუ იდენთიფიკატორი.
              </code>

              ფუნქციაში შეიძლება გამოყენებულ იქნას ლოკალური ცვლადები. <strong>ფუნქციაში აღწერილ ცვლადს
              ეწოდება ლოკალური ცვლადი. ლოკალურ ცვლადებთან წვდომა შეიძლება მხოლოდ ფუნქციის შიგნით</strong>
              <code>
                  function showMessage() { <br>
                      &nbsp;&nbsp;&nbsp; var message = 'Hello !'; // ლოკალური ცვლადი<br>
                      &nbsp;&nbsp;&nbsp; alert( message );<br>
                  }<br>
                  showMessage(); // 'Hello !'<br>
                  alert( message ); // დაფიქცირდება შეცდომა , რადგან ცვლადი მხოლოდ ფუნქციაში "ჩანს"
              </code>

              ფუნქციაში შეიძლება გამოყენებულ იქნას გარე ცვლადები, ანუ ფუნქციის გარეთ აღწერილი ცვლადები
              <code>
                  var city = 'Tbilisi';<br>
                  function showMessage() {<br>
                   &nbsp;&nbsp;&nbsp;   var message = 'Hello ' + city;<br>
                   &nbsp;&nbsp;&nbsp;   alert(message);<br>
                  }<br>
                  showMessage(); // Hello Tbilisi
              </code>

              ფუნქციაში შესაძლებელია გარე ცვლადის არა მარტო წაკითხვა,არამედ მნიშვნელობის შეცვალაც

              <code>
                  var city = 'Tbilisi';<br>
                  function showMessage() {<br>
                   &nbsp;&nbsp;&nbsp;   city = 'Rustavi'; // მოხდა გარე ცვლადზე ახალი მნიშვნელობის მინიჭება<br>
                   &nbsp;&nbsp;&nbsp;   var message = 'Hello ' + city;<br>
                   &nbsp;&nbsp;&nbsp;   alert( message );<br>
                  }<br>
                  showMessage();<br>
                  alert( city ); // Rustavi

              </code>

              <strong>მთლიანი სკრიპტის დონეზე აღწერილ ფუნქციას ეწოდება გლობალური ცვლადი. ზემოთ
              მოყვანილ მაგალითში ცვლადი city არის გლობალური.</strong>

              <h2>ფუნქციის პარამეტრები</h2>

              გამოძახებისა ფუნქციას შეიძლება გადაეცეს მონაცემები, რომლებსაც შემდეგ იგი გამოიყენებს.

              <code>
                  function showMessage(from, text) { // პარამეტრები from, text<br>
                      &nbsp;&nbsp;&nbsp;from = "** " + from + " **";<br>
                      &nbsp;&nbsp;&nbsp;alert(from + ': ' + text);<br>
                  }<br>
                  showMessage('Zoro', 'Hello !');<br>
                  showMessage('Zoro', 'How are you ?');
              </code>

              <strong>პარამეტრები კოპირდება ფუნქციაში აღწერილ ლოკალურ ცვლადებში</strong> <br><br>

              ფუნქციის პარამეტრების ანუ არგუმენტების მითითება შესაძლებელია არა მხოლოდ ფრჩხილებში როგორც ეს
              მოყვანილ შემთხვევაშია არამედ თავად ფუნქციის ტანშიც სიტყვა გასაღებ <strong>arguments</strong>
              დახმარებით. ეს არიც ცვლადი რომელიც თავის თავში მოიცავს ერთგვარ მასივს, ამ მასივის ელემენტები
              კი წარმოადგენენ ფუნქციის არგუმენტებს.<br>
              <code>
                  function myfoo()<br>
                  {<br>
                    &nbsp; var array = arguments;<br>
                    &nbsp; for (i=0;i<=array.length;i++)<br>
                     &nbsp;{<br>
                       &nbsp;&nbsp;console.log(array[i]);<br>
                    &nbsp; }<br>
                  }<br>
                  myfoo("hello","how","are","you"); // arguments[0] = hello, arguments[1] = how ...<br>

              </code>

              <h2>ინსტრუქცია return</h2>

              ხშირ შემთხვევაში საჭიროა ფუნქციამ <strong>დააბრუნოს</strong> რაიმე მნიშვნელობა და ეს მნიშვნელობა
              გადაეცეს  კოდს, რომლიდანაც  მოხდა ამ ფუნქციის გამოძახება. <strong>მნიშვნელობის დასაბრუნებლად
              გამოიყენება  დირექტივა return</strong>. ის შეიძლება განთავსდეს ნებისმიერ ადგილას ფუნქციაში.
              როდესაც javascript-ის ინტერპრეტატორი ხვდება ინსტრუქცია return - ს, ის წყვეტს ფუნქციის მუშაობას
              და აბრუნებს იმ შედეგს , რომელიც return - ის გამოძახების მომენტში აქვს ფუნქციას. მუშაობის გაგრძელება
              არ ხდება არც მაშინ თუ return-ის შემდეგ კიდევ სხვა ოპერატორებიცაა.  მაგალითად გვინდა
              მართკუთხედის ფართობის დათვლა :
              <code>
                  function fartobi(a,b) <br>
                  {<br>
                    c = a*b;<br>
                    return c;<br>
                  }<br>
                  console.log(fartobi(2,5)); // შედეგი იქნება 10
              </code>

              <strong>იმ შემთხვევაში თუ ფუნქციამ  არ დააბრუნა მნიშვნელობა, ან return მითითებულია პარამეტრის
              გარეშე ითვლება, რომ ფუნქციამ დააბრუნა undefined.</strong>
              <code>
                  function doNothing() { /* ცარიელი */ } <br>
                  alert( doNothing() ); // undefined<br><br><br>

                  function doNothing() {<br>
                     &nbsp;&nbsp;&nbsp;return;<br>
                  }<br>
                  alert( doNothing() === undefined ); // true<br>


              </code>


              <h2>რეკურსია</h2>

              <strong>რეკურსია არის მოვლენა, როდესაც რომელიმე ფუნქციაში ხდება ამავე ფუნქციის გამოძახება</strong>
              ამა თუ იმ რთული ამოცანის ამოხსნის პროცესი შეიძლება  წარმოვადგინოთ, როგორც იგივე შინაარსის, შედარებით
              მარტივი ამოცანების ამოხსნის ერთობლიობა. მაგალითისათვის განვიხილოთ რიცხვის ახარისხების ალგორითმი
              pow(x, n). ეს ამოცანა შეიძლება წარმოვადგინოთ ამავე სახის, უფრო მარტივი ამოცანების კომპლექსად
              <code>
                  pow(x, n) = x * pow(x, n - 1) ანუ xn = x * xn-1
              </code>
              გამოვთვალოთ 2<sup>4</sup> და წარმოვადგინოთ ეს გამოსახულება, როგორც შედარებით მარტივი დაფეხურების
              თანმიმდევრობა.
              <ol>
                  <li>pow(2, 4) = 2 * pow(2, 3)</li>
                  <li>pow(2, 3) = 2 * pow(2, 2)</li>
                  <li>pow(2, 2) = 2 * pow(2, 1)</li>
                  <li>pow(2, 1) = 2 </li>
              </ol>
              პირველ ბიჯზე საჭიროა დაითვალოს pow(2,3) ამიტომ გადავდივართ მეორე ბიჯზე. შემდეგ უნდა დაითვალოს
              pow(2,2) ამიტომ გადავდივართ მესამე ბიჯზე, შემდეგ მეოთხეზე და უნდა გავჩერდეთ რადგან რიცხვის პირველ
              ხარისხში აყვანის შედეგე ისევ ეს რიცხვია. ამის შემდეგ მეოთხე ბიჯზე მიღებული შედეგი გამოიყენება მესამე
              ბიჯში და ასე ავდივართ პირველ ბიჯამდე, რაც გვაძლევს შედეგს.

              <code>
                  function pow(x, n) { <br>
                     &nbsp;&nbsp;&nbsp; if (n != 1) {  <br>
                      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return x * pow(x, n - 1);<br>
                     &nbsp;&nbsp;&nbsp; } else {<br>
                      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return x;<br>
                     &nbsp;&nbsp;&nbsp; }<br>
                    }<br>

                  alert( pow(2, 3) ); // 8
              </code>

              ამ შემთხვევაში ამბობენ, რომ ფუნქცია pow რეკურსიულად იძახებს თავის თავას მანამ სანამ n არ გახდება
              1-ის ტოლი.



          </dd>

          <dt>12. ობიექტები</dt>
          <dd class='answer'>
              ობიექტებს ჯავასკრიპტში ახასიათებთ ორი მნიშვნელოვანი ფუნქციონალი :
              <ol>
                  <li>
                      ასოციაციური მასივი - ნებისმიერი მონაცემის შენახვის მოსახერხებელი სტრუქტურა.
                      (ასოციაციური მასივები განხილულია მე-10-ე თავში)
                  </li>
                  <li>ობიექტზე ორიენტირებული პროგრამირების ენობრივი შესაძლებლობები. </li>
              </ol>

              ობიექტის ძალიან ზოგადი განმარტება არის ასეთი: <strong>ობიექტი არის კოდის ფრაგმენტი რომელიც მოიცავს
              მეთოდებსა და თვისებებს, თვისება არის ობიექტის მახასიათებელი, ცვლადს რომელიც აღწერილია ობიექტში
              ეწოდება ობიექტის თვისება, ხოლო ფუნქციას რომელიც აღწერილია ობიექტში - ამ ობიექტის მეთოდი .</strong>
              მაგალითად ობიექტ ვაშლს შეიძლება ჰქონდეს შემდეგი თვისებები: ფერი წონა, სახელი და ა.შ.  მისი ეს თვისებები
              განასხვავებს ამ ობიექტს სხვა ვაშლებისაგან. ყველა ვაშლის ერთობლიობას კი ეწოდება ვაშლების კლასი.<strong>
              ობიექტი არის რომელიმე კლასის კონკრეტული ეგზემპლიარი.</strong>
              <p style="font-weight: bold; text-decoration: underline;">
                  ობიექტზე ორიენტირებულობის თვალსაზრისით javascript დაფუძნებულია სწორედ ამ ეგზემპლიარებზე
                  ანუ ობიექტებზე. მაგრამ მასში კლასებთან მუშაობის პრინციპები ჩაშენებული არ არის, აქედან გამომდინარე
                  ამ ენას OOP ენათა ოჯახს ვერ მივაკუთვნებთ.
              </p>
              ჯავასცრიპტში არსებობს ორი სახის ობიექტები ჩადგმული ობიექტები და სამომხმარებლო ობიექტები, ჩადგმული
              ობიექტია მაგალითად Date() ან Math(), ხოლო სამომხმარებლო ობიექტებია ჩვენს მიერ შექმნილი ნებისმიერი ობიექტი.
              <strong>javascript - ში ობიექტებს ახასიათებთ დინამიურობა ანუ ჩვენ შეგვიძლია დავამატოთთ ან წავშალოთ
              ობიექტის თვისებები. </strong>ობიექტის შექმნა შესაძლებელია <strong>ლიტერალების</strong> მეშვეობით
              ან სიტყვა გასაღები <strong>new</strong> და ფუნქცია კონსტრუქტორ <strong>Object</strong> - ის დახმარებით.
              ლიტერალების დახმარებით ხდება შემდეგნაირად
              <code>
                  var object = {}; // ცარიელი ობიექტი
              </code>
              ფიგურული ფჩხილები javascript - ს მიუთითებს რომ შეიქმნა ობიექტის ლიტერალი. ობიექტის თვისება
              შესაძლებელია იყოს  ობიექტი. მივუთითოთ ობიექტს რამოდენიმე თვისება
              <code>
                  var object = { <br>
                    &nbsp;&nbsp; &nbsp; x : 100, <br>
                    &nbsp;&nbsp; &nbsp; y : 25, <br>
                    &nbsp;&nbsp; &nbsp; string : "hello", <br>
                   &nbsp;&nbsp; &nbsp;  g : { <br>
                    &nbsp;&nbsp;&nbsp;  &nbsp; &nbsp;  a : 50, <br>
                     &nbsp; &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp; b : "string" <br>
                    &nbsp;&nbsp; &nbsp; } <br>
                  };
              </code>

              <h2>მოქმედებები ობიექტებზე</h2>

              შევქმნათ ობიექტი, რომელიც შეინახავს იუნფორმაციას პიროვნებებზე.

              <code>
                  var person = {}; // ჯერ ცარიელია
              </code>
              <img src="images/empty.jpg" style="max-width: 800px;"> <br><br>

              <strong>ძირითადი ოპერაციები ობიექტებთან მუშაობისას არის თვისებების შექმნა, მიღება და წაშლა</strong>
              თვისებაზე წვდომისათვის გამოიყენება <strong>ობიექტი.თვისება</strong> სინტაქსი.
              <code>
                  // თვისების მინიჭებისას ობიექტში ავტომატურად იქმნება "უჯრა" <br>
                  // დასახელებით "name" და მასში იწერება მნიშვნელობა 'Gerasime'<br>
                  person.name = 'Gerasime';<br>
                  person.age = 25; // კიდევ ერთი თვისება: სახელით 'age' და მნიშვნელობა 25<br>
              </code>
              <img src="images/obj.jpg" style="max-width: 800px;"><br><br>
              თვისების მნიშვნელობების წაკითხვისა სინტაქსი ასეთია
              <code>
                  alert( person.name + ': ' + person.age ); // "Gerasime: 25"
              </code>

              თვისების წაშლა ხორციელდება ოპერატორ<strong>delete</strong> -ს დახმარებით
              <code>
                  delete person.age;
              </code>
              დარჩა მხოლოდ თვისება name. ხანდახან საჭიროა შემოწმდეს ამა თუ იმ ობიექტს აქვს თუ არა ესა თუ ის თვისება.
              ამისათვის გამოიყენება ოპერატორი <strong>in</strong>, მისი სინტაქსი ასეთია :
              <code>
                  if ("name" in person) { <br>
                     &nbsp;&nbsp; alert( "თვისება name არსებობს !" );<br>
                  }<br>
              </code>

              <h2>თვისებებთან წვდომა კვადრატული ფრჩხილების გამოყენებით</h2>

              <code>
                  var person = {};
                  person['name'] = 'Gerasime'; // იგივეა რაც  person.name = 'Gerasime'
              </code>

              ჩანაწერები person['name'] და person.name იდენტურია, მაგრამ კვადრატული ფრჩხილების საშუალებით
              შესაძლებელია თვისებას დაერქვას ისეთი სახელი, რომელსაც წერტილის გამოყენებით ვერ დავარქმევდით.
              <code>
                  var person = {}; <br>
                  person['Favorite music genre'] = 'Rock';
              </code>
              რადგან პირველი ცარიელი ადგილის შეხვედრისას ინტერპრეტატორი ჩათვლიდა, რომ თვისების სახელი დამთავრდა
              და შემდეგ გამოიტანდა შეცდომას. <br><br>

              ობიექტს თვისებები შეიძლება მიენიჭოს შექმნისასაც ფიგურული ფრჩხილების დახმარებით <strong>
              { გასაღები1: მნიშვნელობა1, გასაღები2: მნიშვნელობა2, ... }.  ასეთ სინტაქსს ეწოდება ლიტერალი</strong>
              <code>
                  var menuSetup = { <br>
                      &nbsp;&nbsp; width: 300,<br>
                      &nbsp;&nbsp;height: 200,<br>
                      &nbsp;&nbsp;title: "Menu"<br>
                  };
              </code>
              ობიექტის თვისება შეიძლება იყოს ობიექტიც
              <code>
                  var object = { <br>
                    &nbsp;&nbsp; &nbsp; x : 100, <br>
                    &nbsp;&nbsp; &nbsp; y : 25, <br>
                    &nbsp;&nbsp; &nbsp; string : "hello", <br>
                   &nbsp;&nbsp; &nbsp;  g : { <br>
                    &nbsp;&nbsp;&nbsp;  &nbsp; &nbsp;  a : 50, <br>
                     &nbsp; &nbsp;&nbsp;&nbsp;  &nbsp;&nbsp; b : "string" <br>
                    &nbsp;&nbsp; &nbsp; } <br>
                  };
              </code>

              <h2>თვისებების "დათვალიერება"</h2>

              ობიექტის ყველა თვისების სანახავად გამოიყენება ციკლი <strong>for..in</strong>.
              <code>
                  for (key in obj) { <br>
                     &nbsp;&nbsp;&nbsp; /* ... მოქმედება  obj[key] - ზე ... */<br>
                  }<br>
              </code>
              ციკლი for..in თანმიმდევრულად იღებს ობიექტის თვისებებს ობიექტ obj-დან და ათავსებს მას key ცვლადში.

              იმის გასარკვევად აქვს თუ არა ობიექტს ესა თუ ის თვისება გამოიყენება <strong>hasOwnProperty()</strong>
              <code>
                    var object2 = new Object();<br><br>
                    object2.title = "Title";<br><br>
                    object2.text = "Text";<br><br>
                    console.log(object2.hasOwnProperty("title")); // true<br><br>
                    console.log(object2.hasOwnProperty("comments")); // false<br><br>
              </code>


              <h1>ობიექტის მეთოები, this</h1>

              ობიექტის შექმნისას შესაძლებელია მივუთითოთ თვისება-ფუნქცია, მაგალითად
              <code>
                  var user = {  <br>
                    &nbsp;&nbsp;&nbsp;  // თვისება   <br>
                    &nbsp;&nbsp;&nbsp;  name: 'Gerasime',<br><br>

                    &nbsp;&nbsp;&nbsp;  // მეთოდი<br>
                     &nbsp;&nbsp;&nbsp; sayHi: function() {<br>
                      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  alert( 'hello!' );<br>
                     &nbsp;&nbsp;&nbsp; }<br>

                  };<br>

                  // გამოძახება<br>
                  user.sayHi();
              </code>

              <strong>თვისება-ფუნქციას ეწოდება ობიექტის მეთოდი. მეთოდის დამატება და წაშლა ძშესაძლებელია ნებისმიერ
              მომენტში.</strong>

              <h2>ობიექტზე წვდომა, this</h2>

              მეთოდებთან სრულფასოვანი მუშაობისათვის უნდა გვქონდეს წვდომა მოცემულ ობიექტთან. <strong>
              მეთოდიდან ობიექტზე წვდომისათვის გამოიყენება სიტყვა გასაღები this. this-ის უკან იგულისხმება
              ის ობიექტი, რომლელშიც აღწერილია ეს მეთოდი.</strong>
              <code>
                  var user = {  <br>
                    &nbsp;&nbsp;&nbsp;  name: 'Василий',<br>

                    &nbsp;&nbsp;&nbsp;  sayHi: function() {<br>
                    &nbsp; &nbsp;  &nbsp;&nbsp;&nbsp;   alert( this.name );<br>
                    &nbsp;&nbsp;&nbsp;  }<br>
                  };<br>

                  user.sayHi();
              </code>




              <h2></strong>ფუნქცია კონსტრუქტორი</h2>

              ჩვეულებრივი  სინტაქსი {...} საშუალებას გვაძლევს შევქმნათ ერთი ობიექტი, მაგრამ ხშირად საჭიროა შეიქმნას
              ერთი და იგივე ტიპის რამოდენიმე ობიექტი, ამისათვის გამოიყენება <strong>ფუნქცია კონსტრუქტორები, რომლების
              წარმოადგენენ OOP ენების კლასების ანალოგიას. </strong>ფუნქცია კონსტრუქტორი  ახდენს ობიექტის ინიციალიზაციას.
              გამოყენება  ხდეება სპეციალური ოპერატორ <strong>new</strong>- ს საშუალებით.
              <code>
                  function Animal(name) { <br>
                   &nbsp;&nbsp;&nbsp;   this.name = name;<br>
                   &nbsp;&nbsp;&nbsp;   this.canWalk = true;<br>
                  }<br>
                  var animal = new Animal("dog");
              </code>
              აღსანიშნავია, რომ ოპერატორ new-ს საშუალებით, ნებისმიერი ფუნქციის ქცევა შეიძლება ფუნქცია კონსტრუქტორად,
              სხვა ფუნქციებისაგან გამოსაყოფად ფუნქცია კონსტრუქტორების დასახელებები იწყება დიდი ასოთი: Animal და არა
              animal.  უფრო კონკრეტულად, new-ს საშუალებით გამოძახებული ფუნქცია აკეთებს შემდეგს:
              <ol>
                  <li>იქმნება ახალი, ცარიელი ობიექტი</li>
                  <li>სიტყვა გასაღები this ღებულობს წვდომას ამ ობიექტზე</li>
                  <li>ფუნცია სრულდება, ემატება მეთოდები და თვისებები</li>
                  <li>ბრუნდება this</li>
              </ol>

              new Animal("cat"); - ამ ინსტრუქციის შესრულების შედეგად მიიღება ასეთი ობიექტი:
              <code>
                  animal = { <br>
                    &nbsp;&nbsp;  name: "cat",<br>
                    &nbsp;&nbsp;  canWalk: true<br>
                  }
              </code>
              ახლა new Animal ინსტრუქციის მრავალჯერადი გამოყენებით, შეგვიძლია შევქმნათ იმდენი ობიექტი, რამდენიც
              საჭიროა.

              <h1>დესკრიპტორები, getter, setter</h1>

              ობიექტის თვისებების მართვის ძირითადი მეთოდი არის <strong>Object.defineProperty.</strong>.
              მისი გამოყენებით შეგვიძლია განცსაზღვროთ ობიექტის თვისება და რაც მთავარია შესაძლებელია მკაფიოდ
              განისაზღვროს თვისების სზვადასხვა ასპექტები. სინტაქსი ასეთია
              <code>
                  Object.defineProperty(obj, prop, descriptor)
              </code>

              <ul>
                  <li><strong>obj</strong> - ობიექტი, რომელსაც ემატება თვისება.</li>
                  <li><strong>prop</strong> - იმ თვისების სახელი, რომელსაც ვამატებთ. </li>
                  <li>
                      <strong>descriptor</strong> - <label>ობიექტი</label>,რომელიც ასახავს თვისების მახასიათებლებს.
                  </li>
              </ul>

              დესკრიპტორში შეიძლება იყოს შემდეგი ველები:

              <ul>
                  <li><strong>value</strong> - თვისების მნიშვნელობა, გაჩუმების პრინციპით undefined.</li>
                  <li>
                      <strong>writable</strong> - შეიძლება შეიცვალოს თვისების მნიშვნელობა, თუ true.
                      გაჩუმების პრინციპით false.
                  </li>
                  <li>
                      <strong>configurable</strong> - თუ true, მაშინ თვისების წაშლა შეიძლება, აგრეთვე შესაძლებელია
                      მისი შეცვლა შემდეგშიв  defineProperty-ს ახალი გამოძახებით.  გაჩუმების პრინციპით false.
                  </li>
                  <li>
                      <strong>enumerable</strong> - თუ true, მაშინ თვისება განიხილება ციკლში for..in, აგრეთვე
                      მეთოდში  Object.keys(), გაჩუმების პრინციპით false.
                  </li>
                  <li>
                      <strong>get</strong> - ფუნქცია, რომელიც აბრუნებს თვისების მნიშვნელობას. გაჩუმების პრინციპით undefined.
                  </li>
                  <li>
                      <strong>set</strong> - ფუნქცია, რომელიც თვისებას ანიჭებს მნიშვნელობას. გაჩუმების პრინციპით undefined.
                  </li>
              </ul>

              <h2>ჩვეულებრივი თვისების შექმნა დესკრიპტორით</h2>

              <code>
                  var user = {};

                  // 1. უბრალო მინიჭება
                  user.name = "Gerasime";

                  // 2. მნიშვნელობის მითითება დესკრიპტორით
                  Object.defineProperty(user, "name", { value: "Gerasime", configurable: true, writable: true, enumerable: true });
              </code>

              <h2>მეთოდი-ფუნქცია, get,set</h2>

              დესკრიპტორი საშუალებას გვაძლევს შევქმნათ თვისება, რომელიც იმუშავებს, როგორც ფგუნქცია. ამისათვის
              ობიექტში უნდა მივუთითოთ ეს ფუნქცია  get-ის მეშვეობით.
              <code>
                  var user = { <br>
                      &nbsp;&nbsp;&nbsp;firstName: "Вася",<br>
                      &nbsp;&nbsp;&nbsp;surname: "Петров"<br>
                  }<br><br>
                  Object.defineProperty(user, "fullName", {<br>
                      &nbsp;&nbsp;&nbsp;get: function() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.firstName + ' ' + this.surname;<br>
                      &nbsp;&nbsp;&nbsp;}<br>
                  });<br><br>
                  alert(user.fullName); // Вася Петров
              </code>

              აგრეთვე შესაძლებელია მივუთითოთ ფუნქცია, რომელიც გამოიყენება თვისების მნიშვნელობის ჩასაწერად set-ის
              საშუალებით.
              <code>
                  var user = { <br>
                      firstName: "Вася",<br>
                      surname: "Петров"<br>
                  }<br><br>

                  Object.defineProperty(user, "fullName", {<br><br>

                     &nbsp;&nbsp;&nbsp; get: function() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.firstName + ' ' + this.surname;<br>
                     &nbsp;&nbsp;&nbsp; },<br><br>

                     &nbsp;&nbsp;&nbsp; set: function(value) {<br>
                         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var split = value.split(' ');<br>
                          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.firstName = split[0];<br>
                         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.surname = split[1];<br>
                        }<br>
                    &nbsp;&nbsp;&nbsp;});<br><br>

                  user.fullName = "Петя Иванов";<br>
                  alert( user.firstName ); // Петя<br>
                  alert( user.surname ); // Иванов<br>
              </code>


          </dd>

          <dt>13. თარიღი და დრო</dt>
          <dd class='answer'>
              თარიღებთან და დროსთან მუშაობისათვის javascript - ში გამოიყენება ობიექტი <strong>Date,</strong>
              რომელიც გამოძახების მომენტში თავის თავში მოიცავს მიმდინარე დროს. განვიხილოთ მისი მეთოდები
              <code>
                  var date = new Date(); <br><br>
                  console.log(date); // Thu Jan 12 2017 21:01:55 GMT+0400 (Local Standard Time)<br><br>
                  console.log(date.toLocalString); // 1/12/2017, 9:09:18 PM<br><br>
                  console.log(date.toLocaleDateString()); // 1/12/2017<br><br>
                  console.log(date.toLocaleTimeString()); // 9:09:18 PM<br><br>
                  console.log(date.getMonth()); // თუ ახლა არის იანვარი დააბრუნებს 0 - ს (მასივის პრინციპი)<br><br>
                  console.log(date.getDay()); // თვის ანალოგიურად<br><br>
                  console.log(date.getFullYear()); // 2017<br><br>
                  console.log(date.getYear()); // 117 ანუ წლების რაოდენობა 1900 წლიდან :)))<br><br>
                  console.log(date.getHours()); //მიმდინარე საათი  ახლა როცა ამ სტრიქონს ვწერ 21 (21:15 :))) <br><br>
                  console.log(date.getMinutes()); // მიმდინარე წუთი ახლა როცა ამ სტრიქონს ვწერ 17 (21:17 :))) <br><br>
                  console.log(date.getSeconds()); // მიმდინარე წამი ახლა როცა ამ სტრიქონს ვწერ 51 (21:18:51 :))) <br><br>
              </code>

              javascript - ში შესაძლებელია ობიექტ Date - ს ჩვენ მივანიჭოთ ჩვენთვის საჭირო მნიშვნელობები. ამისათვის
              გამოიყენება <strong>Set</strong>
              <code>
                   var date = new Date();<br><br>
                   date.setFullYear(1125);<br><br>
                   date.setMonth(9);<br><br>
                   date.setDate(25);<br><br>
                   console.log(date);<br><br>
              </code>
              გარდა ამისა შესაძლებელია new Date() ობიექტს ჩვენთვის სასურველი თარიღი მივანიჭოთ პარამეტრების
              გადაცემის გზით, სინტაქსი იქნება ასეთი : var date = new Date(წელი,თვე,რიცხვი,საათი,წუთი,წამი,მილიწამი).
              მაგალითად გავარკვიოთ რა დღე იქნება 2017 წლის 1 თებერვალი:
              <code>
                  var date = new Date(2017,1,1);  <br>
                  alert(date.getDay());
              </code>
          </dd>

          <dt>14. შეცდომების კონტროლი try..catch</dt>
          <dd class='answer'>

              როდესაც სკრიპტში ვუშვებთ რაიმე შეცდომას, როგორც წესი სკრიპტის მუშაობა ჩერდება და კონსოლში გამოდის
              შეცდომა. სასურველია რომ  სკრიპტი კი არ წყვეტდეს მუშაობას, არამედ აკეთებდეს რაიმე ალტერნატიულს.
              ამისათვის ჯავასკრიპტში გამოიყენება კონსტრუქცია try..catch, ეს კონსტრუქცია შედგება ორი ბლოკისაგან:
              try და catch.
              <code>
                  try {  <br>
                    &nbsp;&nbsp;  // კოდი ... <br>
                  } catch (err) { <br>
                    &nbsp;&nbsp; // შეცდომის დამუშავება <br>
                  }
              </code>
              კონსტრუქცია მუშაობს ასე :
              <ol>
                  <li>სრულდება ბლოკ try-ში მითითებული ინსტრუქციები.</li>
                  <li>თუ მასში შეცდომები არ არის ბლოკი catch იგნორირდება.</li>
                  <li>
                      თუ try ბლოკში შეცდომები არის მაშინ მართვა გადაეცემა ბლოკ catch(err)-ს. ცვლადი err-ში (ეს სახელი
                      პირობითია) მოთავსდება შეცდომის ობიექტი, რომელშიც შენახული იქნება ინფორმაცია მომხდარი შეცდომის
                      შესახებ.
                  </li>
                  <li></li>
              </ol>
              <strong>ასე და ამგვარად try ბლოკში შეცდომის აღმოჩენის შემდეგ სკრიპტი არ ჩერდება და საშუალება გვეძლევა
              შეცდომა დავამუშავოთ catch ბლოკში.</strong> <br> <br>
              განვიხილოთ ორი ვარიანტი უშეცდომო და შეცდომიანი :
              <code>
                  try {<br><br>

                    &nbsp;&nbsp;&nbsp;   alert('ბლოკ try-ს დასაწყისი');  // (1) <--<br><br>

                    &nbsp;&nbsp;&nbsp;   // .. უშეცდომო კოდი<br><br>

                    &nbsp;&nbsp;&nbsp;   alert('ბლოკ try-ს დასასრული');   // (2) <--<br><br>

                  } catch(err) {<br><br>
                   &nbsp;&nbsp;&nbsp;    alert('ბლოკ CATCH-ს არ გადაეცემა მართვა, რადგანაც შეცდომა არ ფიქსირდება'); // (3)<br><br>

                  }<br><br>

                alert("შემდეგ გაგრძელდება კოდის მუშაობა...");
              </code>

              ახლა განვიხილოთ შემთხვევა, როდესაც try ბლოკში არის შეცდომა:

              <code>
                  try {<br><br>

                     &nbsp;&nbsp;&nbsp; alert('ბლოკ try-ს დასაწყისი');  // (1) <--<br><br>

                     &nbsp;&nbsp;&nbsp; abracadabra; // შეცდომა, ცვლადი განსაზღვრული არ არის!<br><br>

                    &nbsp;&nbsp;&nbsp;  alert('ბლოკ try-ს დასასრული');  // (2)<br><br>

                  } catch(err) {<br><br>

                    &nbsp;&nbsp;&nbsp;  alert('შეცდომა ' + e.name + ":" + e.message + "\n" + e.stack); // (3) <--<br><br>

                  }<br><br>

                   alert("შემდეგ გაგრძელდება კოდის მუშაობა...");
              </code>

              <strong>თუ კოდში უხეში შეცდომაა დაშვებული, მაგალითად ზედმეტი წერტილმძიმეა დასმული ან სადმე აკლია
              ფიგურული ფრჩხილი try...catch მეთოდი ვერაფერს გვიშველის. ასეთ შეცდომებს ეწოდება სინტაქსური
              შეცდომები. ასეთ კოდს ინტერპრეტატორი ვერ გებულობს.  try...catch მეთოდი გვეხმარება სემანტიკური ანუ
              კორექტული კოდის მუშაობის პროცესში წარმოქმნილი შეცდომების დროს.
              </strong>


              <h2>შეცდომების ობიექტი catch(<label>err</label>)</h2>

              ამ ობიექტს აქვს სამი ძირითადი თვისება :
              <ul>
                  <li>
                      <strong>name</strong> - შეცდომის ტიპი, მაგალითად არარსებულ ცვლადზე მიმართვისას
                      "ReferenceError".
                  </li>
                  <li>
                      <strong>message</strong> - ტექსტური შეტყობინება შეცდომის დეტალების შესახებ.
                  </li>
                  <li>
                      <strong>stack</strong> - იგი შეიცავს სტრიქონს,  რომელშიც აღწერილია იმ გამოძახებების
                      თანმიმდევრობა, რომელსაც მოჰყვა შეცდომები.
                  </li>
              </ul>

              <h2>ოპერატორი throw</h2>

              შეიძლება მოხდეს ისეთი შეცდომა, რომელსაც კორექტულად ვერ აღწერს შეცდომის ობიექტი, ბოლოს და ბოლოს
              ამ ობიექტის თვისებებიც ხომ შეზღუდულია და ყველაფერს ვერ მოიცავს, არადა <strong> catch ბლოკი არ
              დაამუშავებს ისეთ შეცდომას, რომელსაც "ვერ ცნობს".</strong>  ასეთ შემთხვევებში გამოიყენება
              throw ოპერატორი, რომელიც საშუალებას გვაძლევს შევქმნათ ე.წ სამომხმარებლო შეცდომები. try.catch და
              throw მეთოდების ერთად გამოყენებით შეგვიძლია ვაკონტროლოთ პროგრამის კორტექტი~ული მუშაობა.
              <br>

              <img src="images/throw.jpg" style="max-width: 800px;"> <br><br>


              <h2>სექცია finally</h2>

              კონსტრუქწცია try..catch კიდევ ერთ ბლოკს: finally. სექცია finally-ს გამოყენება აუცილებელი არ არის,
              მაგრამ თუ ის არსებობს, მაშინ აუცილებლად შესრულდება:
              <ul>
                  <li>ბლოკ try-ს შემდეგ, თუ შეცდომები არ იყო</li>
                  <li>catch-ის შემდეგ, თუ შეცდომები იყო</li>
              </ul>
              ანუ სექცია finally საშუალებას გვაძლევს შევასრულოთ ესა თუ ის კოდი მიუხედავად try..catch ბლოკების
              შედეგისა. (სრულდება მაშინაც კი როდესაც მაგალითად : უშეცდომო try ბლოკში გვიწერია return)<br>

              <img src="images/finally.jpg" style="max-width: 800px;"> <br><br>



          </dd>


          <dt>15. ფორმატი JSON, მეთოდი toJSON</dt>
          <dd class='answer'>

              JSON (JavaScript Object Notation) — JavaScript -ზე დაფუძნებული  მონაცემთა გაცვლის ტექსტური
              ფორმატი, რომელიც ადვილად წაკითხვადია, როგორც მანქანისათვის ისე ადამიანისათვის და რომელიც გამოიყენება
              სერვერსა და ბრაუზერს შორის მონაცემთა გასაცვლელად. <br><br>
              JSON სინტაქსი დაფუძნებულია ჯავასკრიპტის ობიექტის სინტაქსზე:
              <ul>
                  <li>მონაცემები წარმოდგენილია "სახელი":"მნიშვნელობა" ("name":"value") წყვილების სახით.</li>
                  <li>მონაცემები ერთმანეთისგან გამოყოფილია მძიმით.</li>
                  <li>ფიგურულ ფრჩხილებში მოქცეულია ობიექტები.</li>
                  <li>კვადრატულ ფრჩხილებში მოქცეულია მასივები.</li>
              </ul>

              მნიშვნელობa (value) უნდა იყოს შემდეგი ტიპებიდან ერთ-ერთი :
              <ul>
                  <li>ობიექტი (JSON ობიექტი)</li>
                  <li>მასივი</li>
                  <li>boolean</li>
                  <li>null</li>
                  <li>სტრიქონული</li>
                  <li>რიცხვითი</li>
                  <li>undefined</li>
                  <li>ფუნქცია</li>
                  <li>date</li>
              </ul>

              JavaScript–ში JSON-თან სამუშაო ძირითადი მეთოდები არის   :
              <ul>
                  <li><strong>JSON.parse</strong></li>
                  <li><strong>JSON.stringify</strong></li>
              </ul>

              <h2>მეთოდი JSON.parse</h2>

              სერვერიდან მიღებული მონაცემები ყოველთვის არის სტრიქონული ტიპის. JSON.parse(str)  მეთოდის გამოძახებით
              სტრიქონი გარდაიქმნება javascript ობიექტად. წარმოვიდგინოთ, რომ სერვერიდან მოვიდა ინფორმაცია ამ სახით:
              '{ "name":"John", "age":30, "city":"New York"}'
              <code>
                  < p id="demo">< /p > <br>
                  < script ><br>
                  var obj = JSON.parse('{ "name":"John", "age":30, "city":"New York"}');<br>
                  document.getElementById("demo").innerHTML = obj.name + ", " + obj.age; // John, 30<br>
                  < /script ><br>
              </code>

              <code>
                  <h2>JSON-ობიექტი ≠ JavaScript-ობიექტს</h2>
                  JSON-ობიექტი გავს JavaScript-ობიექტს, მაგრამ JavaScript-ობიექტისგან განსხვავებით, JSON-ობიექტის
                  გამოყენებისას ყურადღება ექცევა ბრჭყალების ჩაწერას. <label>JSON-ობიექტში გამოყენებულ უნდა იქნას
                  აუცილებლად ორმაგი ბრჭყალები</label><br>
                  {<br>
                     &nbsp;&nbsp; name: "Gerasime",   // შეცდომა: გასაღები name ბრჭყალების გარეშეა !  <br>
                     &nbsp;&nbsp; "surname": 'Khvichia', // შეცდომა: მნიშვნელობა 'Khvichia' მითითებულია ერთმაგ ბრჭყალებში !<br>
                     &nbsp;&nbsp; "age": 35,   // აქ ყველაფერი სწორადაა<br>
                     &nbsp;&nbsp; "isAdmin": false   // აქაც ყველაფერი სწორადაა<br>
                  }
              </code>

              <h2>მეთოდი JSON.stringify</h2>

              თუ JSON.parse მეთოდი გამოიყენება სტრიქონის ჯავასკრიპტ ობიექტად გარდასაქმნელად, JSON.stringify
              მეთოდი, პირიქით,  სერვერზე გასაგზავნი ინფორმაციის JSON ფორმატში ჩაწერაში გვეხმარება, ანუ ობიექტი
              გადაყავს სტრიქონულ ტიპში.
              <code>
                  var obj = { "name":"John", "age":30, "city":"New York"};
                  var myJSON = JSON.stringify(obj);
              </code>


          </dd>

          <dt>16. OOP ფუნქციონალი ჯავასკრიპტში</dt>
          <dd class='answer'>

              ობიექტზე ორიენტირებული პროგრამირების ერთ-ერთი ძირითადი პრინციპი არის გარე და შიდა
              ინტერფეისების ერმანეთისაგან განცალკევება. განვიხილოთ რომელიმე ცხოვრებისეული მაგალითი,
              ვთქვათ ყაცის მოსადუღებელი :)) მისი გარე ინტეფეისი საკმაოდ მარტივია<br><br>

              <img src="images/coffeeout.jpg">
              <br><br>
              სულ სხვა ვითარებაა შიდა ინტერფეისში :<br><br>
              <img src="images/coffeein.jpg">
              <br><br>
              საკმაოდ ბევრი დეტალია მაგრამ ყავის მადუღარას ისე ვხმარობთ ჩვენ, რომ არც ვიცით არაფერი ამ
              დეტალების შესახებ.

              <h2>შიდა და გარე ინტერფეისი</h2>

              პროგრამირებაში, ობიექტის მეთოდებსა და თვისებებს დავყოფთ ორ ჯგუფად :
              <ul>
                  <li>
                      <strong>შიდა ინტეფეისი</strong> - ეს არის იმ თვისებებისა და მეთოდების ერთობლიობა,
                      რომლებთან წვდომაც შეიძლება მხოლოდ ობიექტის სხვა მეთოდებიდან. მათ ეწოდებათ
                      private მეთოდები (Private - კონფიდენციალური, საიდუმლო, არაოფიციალური).
                  </li>
                  <li>
                      <strong>გარე ინტერფეისი</strong> - ეს არის იმ თვისებებისა და მეთოდების ერთობლიობა,
                      რომლებთან წვდომაც შეიძლება ობიექტის გარედან, ამ მეთოდებს ეწოდება public მეთოდები
                      (Public - საქვეყნო, ხელმისაწვდომი; ღია.)
                  </li>
              </ul>

              <h2>ნაბიჯი 1 : საჯარო(public) და კერძო(private) თვისებები</h2>

              შექმნათ კონსტრუქტორი სახელად CoffeeMachine.

              <code>
                  function CoffeeMachine(power) {  <br>
                    &nbsp;&nbsp;&nbsp;  this.waterAmount = 0; // წყლის რაოდენობა სადუღარში<br><br>

                    &nbsp;&nbsp;&nbsp;  alert( 'შეიქმნა სადუღარა სომძლავრით: ' + power + ' ვატი' );<br>
                  }<br><br>

                  // შევქმნათ სადუღარა<br>
                  var coffeeMachine = new CoffeeMachine(100);<br><br>

                  // ჩავასხათ წყალი :))<br>
                  coffeeMachine.waterAmount = 200;<br>
              </code>
              <strong>ლოკალური ცვლადები, კონსტრუქტორის პარამეტრების ჩათვლით, შეიძლება ჩაითვალოს
              კერძო(private) თვისებებად (ამ შემთხვევაში power). <label>this თან ერთად აღწერილი თვისება
              ან მეთოდი შეიძლება ჩაითვალოს  საჯაროდ(public, რადგან როდესაც კონსტრუქტორის ესა თუ ის ეგზემპლიარი
              შეიქმნება ეს თვისება და ობიექტი მას ავტომატურად მიეკუთვნება.</label></strong>

              <h2>ნაბიჯი 2 : საჯარო(public) და კერძო(private) მეთოდები</h2>

              დავამატოთ მადუღარას ჩამრთველი, საჯარო(public) მეთოდი run და დამხმარე კერძო(private) მეთოდები
              getBoilTime და onReady:

              <code>
                  function CoffeeMachine(power) { <br><br>

                   &nbsp;&nbsp;&nbsp;   this.waterAmount = 0;<br><br>

                   &nbsp;&nbsp;&nbsp;   // დუღილის ხანგრძლივობა<br>
                   &nbsp;&nbsp;&nbsp;   function getBoilTime() {<br>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1000; // ზუსტ ფორმულას დავწერთ მოგვიანებით<br>
                   &nbsp;&nbsp;&nbsp;   }<br><br>

                   &nbsp;&nbsp;&nbsp;  // რა მოხდეს როდესაც პროცესი დამთავრდება<br>
                   &nbsp;&nbsp;&nbsp;   function onReady() {<br>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert( 'ყავა მზადაა !' );<br>
                   &nbsp;&nbsp;&nbsp;   }<br><br>

                   &nbsp;&nbsp;&nbsp;   this.run = function() {<br>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  // setTimeout - ფუნქცია,<br>
                   &nbsp;&nbsp;&nbsp;&nbsp; &nbsp; // ის გაუშვებს onReady-ს  getBoilTime() მილიწამის შემდეგ<br>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  setTimeout(onReady, getBoilTime());<br>
                   &nbsp;&nbsp;&nbsp;   };<br><br>

                   }<br><br>

                    var coffeeMachine = new CoffeeMachine(100);<br>
                    coffeeMachine.waterAmount = 200;<br><br>

                    coffeeMachine.run();   <br>
              </code>

              <strong> <label>onReady, getBoilTim  კერძო(private) მეთოდებია (არ არიან აღწერილები this-თან
              ერთად).მაგალითიდანაც კარგად ჩანს, რომ მათთან წვდომა შესაძლებელია მხოლოდ და მხოლოდ
              კონსტრუქტორის სხვა მეთოდებიდან.</label></strong>

              <h2>ნაბიჯი 3 : კონსტანტა</h2>

              დუღილის ხანგრძლივობის გამოსათვლელად გამოიყენება ფორმულა c*m*ΔT / power, სადაც :
              <ul>
                  <li>c -წყლის თბოტევადობის კოეფიციენტი, ფიზიკური მუდმივაა და უდრის 4200-ს</li>
                  <li>m - წყლის მასა</li>
                  <li>
                      ΔT - გრადუსების რაოდენობა რამდენითაც უნდა გაიზარდოს წყლის საწყისი ტემპერატურა რათა
                      ის ადუღდეს (ჩავთვალოთ, რომ წყალი თავიდან ოთახის ტემპერატურაზეა 20<sup>o</sup>,
                      აქედან გამომდინარე ΔT = 80<sup>o</sup>, რადგან წყალი დუღდება 100<sup>o</sup>-ზე)
                  </li>
                  <li>power - ტევადობა</li>
              </ul>

              გამოვიყენოთ ეს ფორმულა კერძო(private) ფუნქცია getBoilTime()-ში

              <code>
                  "use strict" <br><br>

                  function CoffeeMachine(power) {<br><br>

                   &nbsp;&nbsp;&nbsp;    this.waterAmount = 0;<br><br>

                   &nbsp;&nbsp;&nbsp;    //ფიზიკური კონსტანტა<br>
                   &nbsp;&nbsp;&nbsp;    var WATER_HEAT_CAPACITY = 4200;<br><br>

                   &nbsp;&nbsp;&nbsp;    // დუღილის დროის გამოთვლა<br>
                   &nbsp;&nbsp;&nbsp;    function getBoilTime() {<br>
                    &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;       return this.waterAmount * WATER_HEAT_CAPACITY * 80 / power; // შეცდომა!<br>
                   &nbsp;&nbsp;&nbsp;      }<br><br>

                   &nbsp;&nbsp;&nbsp;    // რა მოხდეს, როდესაც პროცესი დასრულდება<br>
                   &nbsp;&nbsp;&nbsp;    function onReady() {<br>
                    &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;     alert( 'ყავა მზადაა !' );<br>
                   &nbsp;&nbsp;&nbsp;    }<br><br>

                   &nbsp;&nbsp;&nbsp;    this.run = function() {<br>
                    &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;     setTimeout(onReady, getBoilTime());<br>
                   &nbsp;&nbsp;&nbsp;    };<br><br>

                  }<br><br>

                  var coffeeMachine = new CoffeeMachine(1000);<br>
                  coffeeMachine.waterAmount = 200;<br><br>

                  coffeeMachine.run();
              </code>

              WATER_HEAT_CAPACITY კონსტანტა ჩაწერილია დიდი ასოებით, ზემოთ აღწერილი კოდის გაშვებისას
              მეთოდ  getBoilTime-ში მოხდება შეცდომა, თუ რატომ ამას ახლა გავარკვევთ.

              <h2>get და set ფუნქციები</h2>

              თვისებებთან მართვადი წვდომისათვის იყენებენ სპეციალურ ფუნქციებს -  get და set. ზემოთ განხილულ
              მაგალითში მადუღარაში წყლის რაოდენობის მიმთითებელი საჯარო(public) მეთოდი waterAmount.
              <code>
                  function CoffeeMachine(power) { <br>
                   &nbsp;&nbsp;&nbsp;    // მადუღარაში წყლის რაოდენობა<br>
                   &nbsp;&nbsp;&nbsp;     this.waterAmount = 0;<br><br>

                   &nbsp;&nbsp;&nbsp;   ...<br>
                  }
              </code>
              ამ თვისების საჯაროობა სახიფათოა რადგამ მასში შეიძლება ჩაიწეროს ძალიან დიდი მნიშვნელობა მაგალითად
              1000000. ეს რომ არ მოხდეს საჭიროა ვაკონტროლოთ მეთოდი შიდა ინტეფეისიდან, შიდა კოდიდან.
              <strong>მეთოდის კონტროლის საუკეთესო საშუალება კერძო(private) მეთოდად გადაქცევაა, მნიშვნელობის
              ჩაწერა კი ხდება სპეციალური მეთოდის ე.წ "სეთერი" -ს საშუალებით  (setter method).</strong>
              სეთერის ტიპიური დასახელებაა setPropertyName, ანუ ამ შემთხვევაში setWaterAmount:
              <code>
                  function CoffeeMachine(power, capacity) { // capacity - სადუღარის ტევადობა <br><br>

                   ...<br><br>

                   // თვისების "ჭკვიანური" მითითება <br>
                   this.<label>set</label>WaterAmount = function(amount) {<br><br>
                     &nbsp;&nbsp;&nbsp;   if (amount < 0) {<br>
                       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   throw new Error("მნიშვნელობა უნდა იყოს დადებითი");<br>
                     &nbsp;&nbsp;&nbsp;   }<br>
                     &nbsp;&nbsp;&nbsp;   if (amount > capacity) {<br>
                       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   throw new Error("არ ეიძლება " + capacity + " ლიტრზე მეტი წყლის ჩასმა");<br>
                     &nbsp;&nbsp;&nbsp;   }<br><br>

                      &nbsp;&nbsp;&nbsp;  waterAmount = amount;<br>
                    };<br><br>



                   ...<br><br>

                  }
              </code>

              ახლა waterAmount შიდა თვისებაა და მასში მნიშვნელობის ჩაწერა შესაძლებელია სეთერის საშუალებით,
              ეს რაც შეეხებოდა მნიშვნელობის ჩაერას.

              <strong>შიდა მეთოდის მნიშვნელობის წასაკითხად კი გამოიყენება ე.წ გეთერები (getter method).</strong>
              <code>
                  this.getWaterAmount = function() {  <br>
                    &nbsp;&nbsp;&nbsp;    return waterAmount;<br>
                  };
              </code>

              <h1>ფუნქციონალური მემკვიდრეობითობა</h1>

              <strong>მემკვიდრეობითობა – ეს არის უკვე არსებული კლასების საფუძველზე ახალი კლასების შექმნა.
              იმის გასაგებად თუ რა დანიშნულება აქვს ოოპ-ში მემკვიდრეობითობას, განვიხილოთ ისევ და ისევ ცხოვრებისეული
              მაგალითი: ზემოთ მოყვანილ მაგალითებში, ჩვენ ვმუშაობდით ყავის მადუღარაზე, მაგრამ  უეჭველია
              ყოველდღიურობაში მარტო ყავის მადუღარა არაა საკმარისი, ჩვენ გვჭირდება მაცივარიც, ტელევიზორიც,
              პერსონალური კომპიუტერიც და ა.შ ყველა ამ ნივთს აქვს რაღაც საერთო, მაგალითად ჩასართავი ღილაკი,
              დენის წყაროსთან მისაერთებელი კაბელი და ა.შ მემკვიდრეობითობის პრინციპი საშუალებას გვაძლევს შევქმნათ
              რაიმე საბაზისო  კლასი "Machine" და მასში აღვწეროთ ის თვისდებები რაც თითქმის ყველა მოწყობილობას საერთო
              აქვს. ამის შემდეგ კი ამ კლასზე დაყრდნობით შევქმნათ ახალი კლასები "TV", "PC" და ა.შ. რომლებიც
              ავტომატურად მიიღებენ Machine-ში აღწერილ მეთოდებს</strong> <br><br>

              საბაზისო კლას "Machine"-ში აღვწეროთ ყველა ტყექნიკური ხელსაწყოსათვის დამახასიათებელი მეთოდები
              «ჩართვა» enable() და «გამორთვა» disable():
              <code>
                  function Machine() { <br>
                   &nbsp;&nbsp;&nbsp;   var enabled = false;<br><br>

                   &nbsp;&nbsp; &nbsp;  this.enable = function() {<br>
                   &nbsp;&nbsp;&nbsp;&nbsp;     enabled = true;<br>
                   &nbsp;&nbsp;&nbsp;   };<br><br>

                   &nbsp;&nbsp;&nbsp;   this.disable = function() {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;    enabled = false;<br>
                   &nbsp;&nbsp;&nbsp;   };<br>
                  }
              </code>
              ახლა შევქმნათ ამ კლასის მემკვიდრე მადუღარა CoffeeMachine:
              <code>
                  function CoffeeMachine(power) {  <br>
                  &nbsp;&nbsp;&nbsp;    Machine.call(this); // მემკვიდრე<br><br>

                   &nbsp;&nbsp;&nbsp;   var waterAmount = 0;<br><br>

                   &nbsp;&nbsp;&nbsp;   this.setWaterAmount = function(amount) {<br>
                   &nbsp;&nbsp;&nbsp;&nbsp;     waterAmount = amount;<br>
                  &nbsp;&nbsp;&nbsp;    };<br><br>

                  }<br><br>

                  var coffeeMachine = new CoffeeMachine(10000);<br><br>

                  coffeeMachine.enable();<br>
                  coffeeMachine.setWaterAmount(100);<br>
                  coffeeMachine.disable();<br>
              </code>


              <h1>ობიექტის პროტოტიპი</h1>

              ლიტერალებით ან new Object() ხერხით შექმნილი ობიექტები არიან მათი პროტოტიპების მემკვიდრეები, მაგალითად
              new Object() - ის პროტოტიპია Object.prototype. (პროტოტიპი : რისამე პირველადი ნიმუში, პირველსახე,
              დედანი). new Date() - ამ ხერხით შექმნილი ობიექტები არიან Date.prototype-ს მემკვიდრეები. პროტოტიპის
              შექმნის სტანდარტული ხერხი არის ფუნქცია-კონსტრუქტორი :
              <code>
                  function Person(first, last, age, eyecolor) { <br>
                   &nbsp;&nbsp;&nbsp;     this.firstName = first;<br>
                   &nbsp;&nbsp;&nbsp;     this.lastName = last;<br>
                   &nbsp;&nbsp;&nbsp;     this.age = age;<br>
                   &nbsp;&nbsp;&nbsp;     this.eyeColor = eyecolor;<br>
                  }
              </code>
              ამ პროტოტიპისგან ჩვენ შეგვიძლიან შევქმნათ მემკვიდრე ობიექტები სიტყვა გასაღებ new-ს დახმარებით:
              <code>
                  var friend1 = new Person("John", "Doe", 27, "blue"); <br>
                  var friend2 = new Person("Sally", "Rally", 28, "green");
              </code>
              <strong>ფუნქცია კონსტრუქორი Person არის friend1 და friend2 ობიექტების პროტოტიპი.</strong>
              დავამატოთ რაიმე თვისება და მეთოდი რომელიმე ობიექტს:
              <code>
                  friend2.nationality = "Georgian"; <br>
                  friend2.name = function () { <br>
                   &nbsp;&nbsp;&nbsp;     return this.firstName + " " + this.lastName; <br>
                  };
              </code>
              ეს მეთოდი და თვისება დაემატა <strong>მხოლოდ</strong> ობიექტ friend2-ს, friend1-ს კი არა.
              ლოგიკურია, რომ თუ თვისებას და მეთოდს  დავამატებდით პროტოტიპ Person-ს მაშინ ეს თვისება
              დაემატება ამ პროტოტიპის ყველა მემკვიდრე ობიექტს.
              <code>
                  function Person(first, last, age, eyecolor) { <br>
                   &nbsp;&nbsp;&nbsp; this.firstName = first;<br>
                   &nbsp;&nbsp;&nbsp; this.lastName = last;<br>
                   &nbsp;&nbsp;&nbsp; this.age = age;<br>
                   &nbsp;&nbsp;&nbsp; this.eyeColor = eyecolor;<br>
                   &nbsp;&nbsp;&nbsp; this.nationality = "Georgian";<br> // ახალი თვისება
                   &nbsp;&nbsp;&nbsp; this.name = function() {return this.firstName + " " + this.lastName;}; //ახალი მეთოდი
                  }
              </code>

              ახლა პროტოტიპს თვისებები და მეთოდები დავამატოთ თვისება <strong>prototype</strong>-ს საშუალებით.

              <code>
                  function Person(first, last, age, eyecolor) { <br>
                   &nbsp;&nbsp;&nbsp;     this.firstName = first;<br>
                   &nbsp;&nbsp;&nbsp;     this.lastName = last;<br>
                   &nbsp;&nbsp;&nbsp;     this.age = age;<br>
                   &nbsp;&nbsp;&nbsp;     this.eyeColor = eyecolor;<br>
                  }<br><br>
                  Person.prototype.nationality = "English";<br><br>
                  Person.prototype.name = function() {<br>
                   &nbsp;&nbsp;&nbsp;     return this.firstName + " " + this.lastName;<br>
                  };
              </code>


              <h1>"კლასის" შემოწმება - instanceof</h1>

              ოპერატორი instanceof  საშუალებას გვაძლევს გავიგოთ, თუ რომელ კლასს ეკუთვნის ესა თუ ის ობიექტი,
              პროტოტიპული მემკვიდრეობითობიდან გამომდინარე (Instance - მაგალითი, ნიმუში, ცალკეული ფაქტი, შემთხვევა).

              <code>
                  function Rabbit() {}; <br><br>

                  // შევქმნათ ობიექტი<br>
                  var rabbit = new Rabbit();<br><br>

                  // შევამოწმოთ არის თუ არა ამ ობიექტის პროტოტიპი Rabbit?<br>
                  alert( rabbit instanceof Rabbit ); // true
              </code>




          </dd>



          <dt>17. ობიექტი WINDOW, მისი მეთოდები</dt>
          <dd class='answer'>
              <strong>window არის javascript - ის ერთ-ერთი ცენტრალური, გლობალური ობიექტი .</strong> იგი
              არის ბრაუზერში გახსნილი გვერდის ერთგვარი პრეზენტაცია, მას გააჩნია თვისებები  რომლებიც დაკავშირებულნი არიან
              სხვა ობიექტებთან, მაგალითად window ობიექტის ერთ-ერთი თვისებაა location, რომელიც თავის მხრივ ობიექტია და
              აქედან გამომდინარე მასაც გააჩნია თვისებები და მეთოდები.

              <br><br>
              <img src="images/window.jpg" style="max-width: 800px;">
              <br><br>

              ადრე განხილული შეტანა-გამოტანის დიალოგური ფანჯრები (alert,prompt...) არიან windows ობიექტის მეთოდები.
              განვიხილოთ მისი დანარჩენი ძირითადი მეთოდები.

              <h2>setTimeout()</h2>
              იძახებს ფუნქციას ან ასრულებს რაიმე პირობას მილიწამების კონკრეტული რაოდენობის შემდეგ. მისი შებრუნებული
              ოპერაცია არის clearTimeout().
              <code>
                  setTimeout(function(){ alert("Hello"); }, 3000); // 3 წამში გაჩნდება alert ფანჯარა, 1000 მს = 1 წამი
              </code>

              <h2>setInterval()</h2>
              იძახებს ფუნქციას ან ასრულებს რაიმე პირობას მილიწამების კონკრეტული რაოდენობის შემდეგ. მისი შებრუნებული
              ოპერაცია არის clearInterval().
              <code>
                   setInterval(function(){ alert("Hello"); }, 3000); // ყოველ 3 წამში გაჩნდება alert ფანჯარა,
              </code>

              <h2>open()</h2>
              თუ ამ მეთოდა პარამეტრად არაფერს მივუთითებთ მაშინ გახსნის ახალ ცარიელ ფანჯარას ბრაუზერში, თუ მივუთითებთ
              მაშინ გახსნის მითითებულ გვერდს (აგრეთვე შესაძლებელია ახალი ფანჯრის სიგრძე/სიგანის , ბრაუზერის ხელსაწყოების
              მდგომარეობის და ა.შ მითითება). ამ მეთოდის საპირისპირო მეთოდია close().
              <code>
                   window.open("http://www.w3schools.com");
              </code>

              <h2>stop()</h2>
              ეს მეთოდი აჩერებს გვერდის ჩატვირთვას. stop() გამოიყენება მაგალითად თუ სურათის ან ფრეიმის ჩატვირთვას
              ჭირდება დიდი დრო.
              <code>
                   window.stop();
              </code>

              <h2>scrollTo(x,y), scrollBy(x,y))</h2>
              <code>
                   window.scrollTo(500,0); // ჰორიზონტალური სქროლი პოზიცია 500 - ზე
                   window.scrollTo(300,500); // 300 ჰორიზონტალურად 500 ვერტიკალურად
              </code>

              <h2>moveBy()</h2>
              გადააადგილებს ფანჯარას მისი საწყისი პოზიციიდან
              <code>
                   window.moveBy(x,y);
              </code>

              <h2>moveTo()</h2>
              გადააადგილებს ფანჯარას ეკრანის მარცხენა ზედა კუთხიდან
              <code>
                   window.moveTo(x,y);
              </code>

              <h2>print()</h2>
              ბეჭდავს მიმდინარე ფანჯარას
              <code>
                   window.print();
              </code>

              <h2>resizeBy(x,y) და resizeTo(x,y)</h2>
              პირველი ზრდის ბევრჯერ მეორე ერთხელ (???)
              <code>
                   window.resizeBy(250,250);
              </code>

              <h2>frames</h2>
              მიმდინარე ფანჯარაში შემავალ iframe ელემენტებთან წვდომა. აბრუნებს ფრეიმების მასივს, მაგალითად თუ გვინდა
              პირველი ფრეიმის ბმულის შეცვლა ვიქცევით ასე
              <code>
                   window.frames[0].location = "http://www.w3schools.com/jsref";
              </code>



          </dd>

          <dt>18.ობიექტი WINDOW, მისი თვისებები Location, History (BOM)</dt>
          <dd class='answer'>

              BOM ანუ Browser Object Model <br><br>

              <strong>Location</strong> - ობიექტი, რომელიც მოიცავს ინფორმაციას მიმდინარე, გახნილი URL - ის
              შესახებ. (URL - Uniform Resource Locator ანუ წყაროს ადგილმდებარეობის ლოკატორი/განმსაზღვრელი).
              განვიხილოთ მისი თვისებები
              <code>
                  location.hash <br>
                  /*<br>
                      აბრუნებს ან მიუთითებს ბმულის ე.წ ანკორულ ნაწილს,
                      სიტყვა anchor ნიშნავს ღუზის ჩაშვებას, დამაგრებას მიმაგრებას,დაფიქსირებას ანუ ბმულის ანკორულ ნაწილში
                      შეიძლება ვიგულისხმოთ ის ნაწილი რომელიც ბმულის საბოლოო დამფიქსირებელია, მაგალითად
                      თუ URL არის http://www.example.com/test.htm#part2 დააბრუნებს #part2<br>
                  */<br><br>
                  location.host // აბრუნებს ან მიუთითებს მიმდინარე url - ის შესაბამის პორტს  და დომეინს<br><br>
                  location.hostname // აბრუნებს ან მიუთითებს მიმდინარე url - ის შესაბამის დომეინს<br><br>
                  location.href // აბრუნებს ან მიუთითებს მიმდინარე url - ის შიგთავსს<br><br>
                  location.protocol // აბრუნებს ან მიუთითებს მიმდინარე url - ის პროტოკოლს<br><br>
                  location.pathname //  აბრუნებს ან მიუთითებს მიმდინარე url - ის path - ს<br><br>
                  location.search<br>
                  /*<br>
                      აბრუნებს ან მიუთითებს მიმდინარე url ის ე.წ მოთხოვნით
                      ნაწილს "?" ნიშნის ჩათვლით. ბმულის მოთხოვნითი ნაწილი ეწოდება "?" ნიშნის შემდეგ ბმულის ნაწილს,
                      ეს ნაწილი ხშირად გამოიყენება პარამეტრების მისათითებლად. მაგალითად თუ მიმდინარე url  არის
                      http://www.w3schools.com/submit.htm?email=someone@example.com, location.search
                      დააბრუნებს - ?email=someone@example.com <br>
                  */
              </code>


              ახლა გაბვიხილოთ location ობიექტის მეთოდები
              <code>
                  location.assign("http://www.w3schools.com"); // მიმდინარე ფანჯარაშივე ხსნის მითითებულ url - ს<br><br>
                  location.reload(); // მიმდინარე ფანჯრის დარეფრეშება<br><br>
                  location.replace(http://www.w3schools.com);<br>
                  /*<br>
                      location.assign - ის მსგავსად მიმდინარე ფანჯარაში ხსნის მითითებულ url - ს, იმ განსხვავებით, რომ
                      მომხმარებლის მიერ გახსნილი url - ების ისტორიაში ახალი ჩანაწერი არ გაკეთდება, გადაკეთდება ბოლო ჩანაწერი.<br>
                  */
              </code>


              <br><br>



              <strong>Histrory</strong> - ობიექტი, რომელიც მოიცავს ინფორმაციას მომხმარებლის მიერ გახნილი URL - ების
              შესახებ. ამ ობიექტს აქვს მხოლოდ ერთი თვისება ესაა length
              <code>
                  history.length; // დააბრუნებს ლინკების რაოდენობას ისტორიაში
              </code>
              ახლა განვიხილოთ history ობიექტის მეთოდები
              <code>
                  window.history.back(); // ჩატვირთავს წინა ბმულს ისტორიიდან<br><br>
                  window.history.forward(); // ჩატვირთავს შემდეგ ბმულს ისტორიიდან<br><br>
                  window.history.go(-2); // ჩატვირთავს კონკრეტულ ბმულს ისტორიიდან<br><br>
              </code>


          </dd>



          <dt>19. ობიექტი WINDOW, მისი თვისებები Screen, Navigator (BOM)</dt>
          <dd class='answer'>
              როგორც ცნობილია javascript ინტერპრეტატორის მიმართ სხვადასხვა ბრაუზერები სხვადასხვანაირად არიან
              "განწყობილნი", არის შემთხვევები როდესაც ერთი და იგივე სკრიპტი ერთ ბრაუზერში მუშაობს მეორეში არა
              და ა.შ, აქედან გამომდინარე ხშირადა საჭიროა  ბრაუზერის შესახებ ინფორმაციის კოდში გამოყენება. <strong>
              Navigator</strong> - ობიექტი, რომელიც ინახავს ინფორმაციას ბრაუზერის შესახებ. განვიხილოთ  მისი
              თვისებები

              <code>
                  navigator.appName; <br>
                  /*<br>
                      IE11, Firefox, Chrome და Safari აბრუნებს "Netscape" -ს, <br>
                      IE 10 და უფრო ძველი ვერსიები აბრუნებს "Microsoft Internet Explorer" - ს <br>
                      Opera აბრუნებს "Opera" - ს<br>
                  */<br><br>
                  navigator.appVersion; // ბრაუზერის ვერსია, პლატფორმა და ა.შ <br><br>
                  navigator.userAgent; // ბრაუზერის ვერსია, პლატფორმა და ა.შ <br><br>
                  navigator.platform // ინფორმაცია პლატფორმის შესახებ<br><br>
                  navigator.cookieEnabled; // ჩართულია თუ არა ბრაუზერში cookie  (true/false)<br><br>
                  navigator.onLine; // არქვს თუ არა ბრაუზერს წვდომა ინტერნეტთან (true/false)
              </code>

              Navigator ობიექტის მეთოდები
              <code>
                  navigator.javaEnabled(); // აქვს თუ არა ბრაუზერს java - ს მხარდაჭერა (true/false)
              </code>

              <br><br>


              <strong>Screen</strong>  - ობიექტი, რომელიც მოიცავს ინფორმაციას ეკრანის სიგრძე-სიგანისა და ფერთა
              სიხშირის შესახებ . განვიხილოთ მისი თვისებები
              <code>
                  screen.availHeight; // ეკრანის დასაშვები/ხელმისაწვდომი სიმაღლე windows ტასკბარის გარეშე<br><br>
                  screen.availWidth // ეკრანის დასაშვები/ხელმისაწვდომი სიგანე windows  ტასკბარის გარეშე<br><br>
                  screen.height // ეკრანის მთლიანი  სიმაღლე, სხვადასხვა ბრაუზერში სხვადასხვაა :((<br><br>
                  screen.width // ეკრანის მთლიანი სიგანე, სხვადასხვა ბრაუზერში სხვადასხვაა :((
                  screen.colorDepth
              </code>

          </dd>


          <dt>20. DOM </dt>
          <dd class='answer'>
              DOM არის W3C - ს(World Wide Web Consortium ანუ მსოფლიო ქსელის კონსორციუმი) სტანდარტი,
              ობიექტებად აღწერილი დოკუმენტი ანუ დოკუმენტის ობიექტური მოდელი, რომელსაც ბრაუზერი ქმნის მანამ სანამ
              გვერდი ჩაიტვირთება. DOM - ის საშუილებით  javascript - ი  HTML - ს ხდის გაცილებით დინამიურს რადგან :
              <ul>
                  <li>javascript - ს შეუძლია შეცვალოს ნებისმიერი HTML ელემენტი</li>
                  <li>javascript - ს შეუძლია შეცვალოს ნებისმიერი HTML ატრიბუტი</li>
                  <li>javascript - ს შეუძლია შეცვალოს ნებისმიერი CSS სტილი</li>
                  <li>javascript - ს შეუძლია წაშალოს ნებისმიერი HTML ატრიბუტი და ელემენტი</li>
                  <li>javascript - ს შეუძლია დაამატოს HTML ატრიბუტი და ელემენტი</li>
                  <li>javascript - ს შეუძლია რეაგირება მოახდინოს  HTML მოვლენებზე (event)</li>
                  <li>javascript - ს შეუძლია შექმნას ახალი მოვლენა HTML - ში</li>
              </ul>

              <h3>რა არის HTML DOM ?</h3>
              HTML DOM არის სტანდარტული მოდელი და პროგრამული ინტერფეისი  HTML - სათვის, რომელშიც HTML ელემენტები
              განიხილება როგორც ობიექტები => საშუალება გვაქვს ვიმოქმედოთ მათ თვისებებზე, ვიმოქმედოთ მათი მეთოდებით
              და მოვლენებით.
              <br><br>
              <img src="images/dom.jpg" style="max-width: 800px;"> <br><br>
              სურათზე მოცემულია DOM - ის ხე, რომელიც შეიცავს მართკუთხედში ჩასმულ HTML ელემენტებს და ტეგებს, ამ
              ელემენტებს და ტეგებს ეწოდებათ კვანძები (nodes). კვანძები შეიძლება დავყოთ შემდეგნაირად
              <ul>
                  <li>თავად document კვანძი, ძირითადი კვანძი</li>
                  <li>html ელემენტები (element)</li>
                  <li>html ატრიბუტები (atribute)</li>
                  <li>ტექსტები html ელემენტებში (text)</li>
                  <li>html კომენტარები</li>
              </ul>

              DOM-ში პირველი შესავალი წერთილი არის – document.documentElement, ანუ ტეგი  < html>.
              მეორე შესავალი წერტილი არის  document.body ანუ < BODY> ტეგი. თანამედროვე ბრაუზერებში (IE8- გარდა)
              აგრეთვე შესაძლებელია document.head = < head> ტეგთან წვდომაც. <br></br>

              <strong><label>არ შეიძლება სკრიპტიდან წვდომა დავამყაროთ იმ ელემენტთან, რომერლიც ჯერ კიდევ არ არის
              შექმნილი სკრიპტის გამოძახების მომენტში. ხშირ შემთხვევაში, როდესაც სკრიპტი მოთავსებულია < head>
              ტეგში, მისთვის მიუწვდომელია document.body ანუ body ტეგი </label></strong>

              <code>
                  &lt;!DOCTYPE HTML> <br>
                  &lt;html><br><br>

                   &lt;head><br>
                      &lt;script><br>
                       &nbsp;&nbsp;&nbsp;alert(document.body); // null, body ჯერ კიდევ არ არსებობს<br>
                      &lt;/script><br>
                    &lt;/head><br><br>

                    &lt;body><br><br>

                      &lt;script><br>
                       &nbsp;&nbsp;&nbsp; alert(document.body); // body შექმნილია უკვე<br>
                      &lt;/script><br><br>

                    &lt;/body><br><br>

                  &lt;/html>
              </code>

              <strong>DOM-ის სამყაროში არარსებული კვანჟის ან ელემენტის აღმნიშვნელი მნიშვნელობა  არის არა undefined
              არამედ null</strong>


              <code>
                  რომელიღაც X კვანძზე <label style="font-weight: bold; text-decoration: underline;">ერთი</label>
                  საფეხურით ზემოთ   მდგომ კვანძს ეწოდება მშობელი კვანძი .  მაგალითად ნახაზზე კვანძი
                  "strong" - ის მშობელი არის მხოლოდ და მხოლოდ კვანძი "p"  და არა ვთქვათ "body".
              </code>
              <code>
                  რომელიღაც X კვანძზე <label style="font-weight: bold; text-decoration: underline;">ერთი</label>
                  საფეხურით ქვემოთ  მდგომ კვანძს ეწოდება შვილობილი კვანძი .  მაგალითად ნახაზზე კვანძი
                  "body" - ს შვილობილები არიან  კვანძი "p"  და კვანძი "h1".
              </code>
              <code>
                  იერარქიულად ერთიდაიგივე საფეხურზე მდგომ, ერთიდაიგივე მშობელი კვანძის შვილობილ კვანძებს ეწოდება
                  ძმური კვანძები :))) მაგალითად კვანძი "p"  და კვანძი "h1" არიან ძმური კვანძები.
              </code>
              <code>
                  რომელიმე X კვანძზე 2 და მეტი საფეხურით ქვემოთ მდგომ კვანძებს ეწოდებათ X კვანძის შთამომავლები,
                  მაგალითად კვანძი "p"  და კვანძი "h1" არიან კვანძი html - ის შთამომავლები ანუ სხვანაირად html
                  არის "p" - ს   და  "h1" - ის წინაპარი.
              </code>

          </dd>

          <dt>21. DOM ნავიგაცია</dt>


          <dd class='answer'>

              <strong>ამა თუ იმ სელექთორით ამორჩეული ელემენტების ერთობლიობა შეიძლება განვიხილოთ, <label>როგორც
              ელემენტების კოლექცია და არა მასივი.</label> მაგალითად თუ ავარჩევთ ისეთ ელემენტებს, რომელთა კლასიც
              არის "my_class", მივიღებთ რამოდენიმე ელემენტისაგან შექმნილ ჯგუფს, კოლექციას, რომელთან მიმართებაშიც
              შეგვეძლება გამოვიყენოთ მასივისათვის დამახასიათებელი თვისება length, მაგრამ ეს არ ნიშნავს, რომ ეს კოლექცია
              მასივია, კოლექციასთან მუშაობისას ვერ გამოვიყენებთ ისეთ ფუნქციებს როგორებიცაა : forEach, map, push, pop
              და სხვ.</strong>

              <h1>ელემენტების ძებნა , სელექთორები</h1>

              <h2>getElementById</h2>

              ელემენტების ამორჩევა DOM - ში შესაძლებელია რამდენიმენაირად, ერთ-ერთი საშუალებაა id - ს მიხედვით
              ამორჩევა - getElementById, რომელიც აბრუნებს null - ს თუ ვერ მოიძებნება მითითებული id - ს  მქონე
              ელემენტი. თუ რამოდენიმე ელემენტს აქვს ერთნაირი id ძნელია განისაზღვროს თუ როგორ მოიქცევა ინტერპრეტატორი,
              არ არის გარანტია იმისა, რომ აარჩევს პირველს ან ბოლოს. <strong>ამიტომ სასურველია დავიცვათ id-ის
              უნიკალურობის პრინციპი.</strong>
              <code>
                  var elem = document.getElementById("my_text"); <br><br>
                  elem.innerHTML = "new html";
              </code>

              <h2>getElementsByName</h2>

              შემდეგი ხერხი არის სახელის მიხედვით ამორჩევა - getElementsByName, როგორც ვხედავთ სიტყვა element
              ამ შემთხვევაში არის მრავლობით ფორმაში იმიტომ რომ ერთი და იგივე  სახელი შეიძლება ერქვას რამოდენიმე
              ელემენტს => getElementsByName აბრუნებს object NodeList - ს ანუ კვანძების <strong>კოლექციას
              </strong>, რომელთან მუშაობისასაც  შეგვიძლია გამოვიყენოთ length მეთოდი.
              <code>
                  var elem = document.getElementsByName("my_name"); <br><br>
                  elem[0].innerHTML = "Node List";
              </code>

              <h2>getElementsByTagName</h2>

              შემდეგი ხერხი არის ტეგის სახელის მიხედვით ამორჩევა - getElementsByTagName, აბრუნებს ელემენტების
              კოლექციას. დაბრუბებულ კოლექციასთან ანუ ობიექტთან მიმართებაში  შეგვიძლია გამოვიყენოთ length ანუ
              გავიგოთ თუ  რამდენი ელემენტი მოხვდა კოლექციაში ,თუ პარამეტრად მიეთითება "*", მაშინ ამოარჩევს
              დოკუმენტის  ყველა ელემენტს. (პარამეტრის მითიტებისას რეგისტრს მნიშვნელობა არ აქვს იმდენად
              რამდენადაც თავად HTML არ არის რეგისტრზე დამოკიდებული)
              <code>
                  var elem = document.getElementsByTagName("p"); <br><br>
                  elem[0].innerHTML = "Selected by tagName";
              </code>
              <strong>უნდა აღინიშნოს, რომ getElementById-სგან განსხვავებით, რომელიც მოქმედებს მხოლოდ document
              კონტექსტში, მეთოდი getElementsByTagName შეიძლება გამოვიყენოთ ნებისმიერ ელემენტში</strong>
              <code>
                  var tableElem = document.getElementById('age-table'); <br>
                  var elements = tableElem.getElementsByTagName('input');
              </code>

              <h2>getElementsByClassName</h2>

              შემდეგი ხერხი არის  კლასის მიხედვით ამორჩევა - getElementsByClassName, იგი აბრუნებს
              ელემენტების კოლექციას => აქაც შეიძლება გამოვიყენოთ length.
              <code>
                  var elem = document.getElementsByName("my_name"); <br><br>
                  elem[0].innerHTML = "Node List";
              </code>

              <h2>querySelector</h2>

              შემდეგი ხერხი არის CSS სელექთორების მიხედვით ამორჩევა , ამოირჩევა ერთი და იგივე css მახასიათებლების
              მქონე  ელემენტებიდან მხოლოდ პირველი - querySelector, ხოლო თუ ყველა მათგანის არჩევა გვინდა
              querySelectorAll რომელიც აგრეთვე კვანძების კოლექციას სახით ბრუნდება და შეგვიძლია გამოვიყენოთ length.
              მაგალითად ამოვარჩიოთ ყველა  < p > ელემენტი რომლის კლასიცაა "menu"
              <code>
                  var elem = document.querySelectorAll("p.menu"); <br><br>
                  elem[0].innerHTML = "Node List";
              </code>
              ახლა ამოვარჩიოთ ყველა სიის ბოლო ჩანაწერები
              <code>
                  &lt;ul> <br>
                  &nbsp;&nbsp;&nbsp;    &lt;li>სია&lt;/li><br>
                  &nbsp;&nbsp;    &lt;li>პირველი&lt;/li><br>
                  &lt;/ul><br><br>
                  &lt;ul><br>
                  &nbsp;&nbsp;&nbsp;    &lt;li>სია&lt;/li><br>
                  &nbsp;&nbsp;&nbsp;   &lt;li>მეორე&lt;/li><br>
                  &lt;/ul><br><br>

                  &lt;script><br>
                  &nbsp;&nbsp;&nbsp;    var elements = document.querySelectorAll('ul > li:last-child');<br><br>

                  &nbsp;&nbsp;&nbsp;    for (var i = 0; i < elements.length; i++) {<br>
                     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     alert( elements[i].innerHTML ); // "პირველი", "მეორე"<br>
                   &nbsp;&nbsp;&nbsp;   }<br>
                  &lt;/script>
              </code>


              <h2>HTML ცხრილებთან მუშაობა</h2>

              DOM-ის კონკრეტულ ელემენტებს შეიძლება გააჩნდეთ საკუთარი, დამატებითი მეთოდები უფრო კომფორტული
              ნავიგაციისათვის. მაგალითად განვიხილოთ HTML ცხრილი, მასთან სამუშაოდ გამოიყენება :

              <h3>TABLE</h3>
              <ul>
                  <li><strong>table.rows</strong> – ცხრილის TR სტრიქონების კოლექცია</li>
                  <li><strong>tr.cells </strong> – უჯრების კოლექცია TD/TH</li>
                  <li><strong>tr.rowIndex</strong>  – სტრიქონის ნომერი ცხრილში</li>
                  <li><strong>td.cellIndex</strong>  – უჯრის ნომერი სტრიქონში</li>
              </ul>





              <h1>ელემენტების ამორჩევა ნათესაობითობის მიხედვით</h1>

              <h2>elem.parentNode</h2>

              ვთქვათ გვაქვს ელემენტი რომლის id არის "for_parent", მისი მშობელი კვანძის, ელემენტის საპოვნელად
              გამოიყენება  შემდეგი ჩანაწერი:
              <code>
                  var elem = document.getElementById("for_parent")<br><br>
                  alert(elem.parentNode); <br><br>
                  /* <br>
                    &nbsp;&nbsp;&nbsp;სიტყვა node მხოლობით ფორმაშია რადგან ამა თუ იმ
                    ელემენტს მშობელი შეიძლება ჰყავდეს მხოლოდ ერთი<br>
                  */
              </code>

              <h2>elem.childNodes</h2>

              ვთქვათ  ელემენტს  id - ით  "for_parent", თავის მხრივ ყავს შვილობილი ელემენტები,კვანძები,
              <code>
                  var elem = document.getElementById("for_parent")<br><br>
                  alert(elem.childNodes); <br><br>
                  /* <br>
                    &nbsp;&nbsp;&nbsp;სიტყვა node მრავლობით ფორმაშია რადგან ელემენტს შეიძლება<br>
                    &nbsp;&nbsp;&nbsp;ჰყავდეს რამოდენიმე შვილი, აგრეთვე <br>
                  */
              </code>
              <strong>აღსანიშნავია, რომ childNodes გამოყენების დროს ელემენტებში არსებული სიცარიელეები აღიქმება
              როგორც ტექსტი, ტექსტი კი აღიქმება  როგორც კვანძი ანუ node.<br></strong>

              <h2>children </h2>

              თუ გვსურს, რომ ავარჩიოთ რომელიმე ელემენტის არაცარიელი შვილობილები, ანუ ისეთები, რომლებიც არ არიან
              ტექსტური ტიპისანი და არიან HTML ელემენტები უნდა გამოვიყენოთ children მეთოდი
              <code>
                  var list = document.getElementById("my_ul");<br>
                  var childs = list.children;<br>
                  for(var i=0;i < childs.length;i++){<br>
                      &nbsp;&nbsp; alert(childs[i].innerHTML);<br>
                  }
              </code>

              <h2>firstChild, lastChild </h2>

              დავუშვათ გვინდა ამოვარჩიოთ ბოლო ან პირველი შვილობილი ელემენტი, ამისათვის გამოიყენება firstChild
              და lastChild მეთოდები.
              <code>
                  var elem = document.getElementById("for_parent")<br><br>
                  alert(elem.firstChild.innerHTML); <br><br>
                  alert(elem.lastChild.innerHTML); <br><br>
              </code>

              <h2>nodeValue</h2>

              ტექსტური კვანძების შიგთავსის გამოსატანად გამოიყენება nodeValue
              <code>
                  var elem = document.getElementById("for_parent");<br><br>
                  alert(elem.firstChild.nodeValue); <br><br>
              </code>

              <h2>previousSibling და nextSibling</h2>

              ახლა განვიხილოთ მოძმე ანუ იერარქიულად ერთნაირ საფეხურზე მდგომ კვანძებთან წვდომა, ამისათვის
              გამოიყენება previousSibling და nextSibling (Sibling - და ან ძმა, დედმამიშვილი)
              <code>
                  var elem = document.getElementById("for_parent"); <br><br>
                  alert(elem.previousSibling);   <br><br>
                  alert(elem.nextSibling);   <br><br>
              </code>

              <strong>ზემოთ მოყვანილ მეთოდებში როგორც ვნახეთ ელემენტად ითვლება ცარიელი ადგილები, რაც საკმაოდ
              მოუხერხებელი და არაკომფორტულია. ამის თავიდან ასაცილებლად გამოიყენება previousElementSibling,
              nextElementSibling, firstElementChild , lastElementChild და  მეთოდები, რომლებიც ტექსტურ
              კვანძებს უგულებელჰყოფენ.</strong><br><br>

              <strong>previousSibling</strong><br><br>
              <img src="images/presibling.jpg" style="max-width: 800px;"> <br><br>
              <strong>previousElementSibling</strong><br><br>
              <img src="images/preelsibling.jpg" style="max-width: 800px;"> <br><br>

              <h2>childElementCount</h2>

              შვილობილი ელემენტების რაოდენობის დასათვლელად გამოიყენება childElementCount მეთოდი

              <code>
                  var elem = document.getElementById("for_parent"); <br><br>
                  alert(elem.childElementCount);   <br><br>
              </code>






          </dd>

          <dt>22. DOM , მოქმედებები ელემენტებზე</dt>
          <dd class='answer'>

              <h1>ელემენტების შექმნა</h1>

              ტექსტური კვანძების შესაქმნელად გამოიყენება მეთოდი createTextNode('text')
              <code>
                  var textElem = document.createTextNode('Hello !');
              </code>

              ელემენტის შესაქმნელად გამოიყენება მეთოდი createElement("div")
              <code>
                  var div = document.createElement('div');
              </code>

              <h1>ელემენტების დამატება</h1>

              იმისათვის რათა DOM კვანძი გამოჩნდეს გვერდზე, კვანძი უნდა ჩავსვათ document-ში. დავუშვათ ელემენტს
              ვამატებთ document-ის შვილობილ parentElem ელემენტში, ვთქვათ var parentElem = document.body.
              parentElem-ში რაიმეს ჩასამატებლად გამოიყენება შემდეგი მეთოდები :

              <h3>parentElem.appendChild(elem)</h3>

              ამატებს elem-ს parentElem-ის ბოლო შვილობილი ელემენტის შემდეგ.

              <code>
                  &lt;ol id="list">  <br>
                   &nbsp;&nbsp;&nbsp;   &lt;li>0&lt;/li><br>
                   &nbsp;&nbsp;&nbsp;   &lt;li>1&lt;/li><br>
                   &nbsp;&nbsp;&nbsp;   &lt;li>2&lt;/li><br>
                  &lt;/ol><br><br>

                  &lt;script><br>
                  &nbsp;&nbsp;&nbsp;    var newLi = document.createElement('li');<br>
                  &nbsp;&nbsp;&nbsp;    newLi.innerHTML = 'hello!';<br><br>

                  &nbsp;&nbsp;&nbsp;    list.appendChild(newLi);<br>


                  &lt;/script>


              </code>


              <h3>parentElem.insertBefore(elem, nextSibling)</h3>

              ამატებს elem  parentElem-ის შვილების კოლექციაში, nextSibling-ად მითითებული ელემენტის წინ.
              მაგალითად ეს კოდი ჩაამატებს ახალ ელემენტს მეორე li-ს შემდეგ

              <code>
                  &lt;ol id="list"><br>
                   &nbsp;&nbsp;&nbsp;    &lt;li>0&lt;/li><br>
                   &nbsp;&nbsp;&nbsp;    &lt;li>1&lt;/li><br>
                   &nbsp;&nbsp;&nbsp;    &lt;li>2&lt;/li><br>
                  &lt;/ol><br><br>

                  &lt;script><br>
                   &nbsp;&nbsp;&nbsp;   var newLi = document.createElement('li');<br>
                   &nbsp;&nbsp;&nbsp;   newLi.innerHTML = 'Привет, мир!';<br><br>

                   &nbsp;&nbsp;&nbsp;   list.insertBefore(newLi, list.children[1]);<br>
                  &lt;/script>
              </code>

              თუ გვსურს, რომ ელემენტის დასაწყისში დავამატოთ ახალი ელემენტი ამისათვის უნდა მივუთითოთ, რომ
              ვამატებთ პირველი შვილობილი ელემენტის წინ:
              <code>
                  list.insertBefore(newLi, list.firstChild);
              </code>
              მაგრამ რა მოხდება იმ შემთხვევაში თუ ელემენტი list ცარიელია ? მაშინ ხომ არ იარსებებს firstChild ?
              <strong>საქმე იმაშია, რომ თუ მეორე პარამეტრად მითითებულია null, მაშინ insertBefore მუშაობს, როგორც
              appendChild:</strong>
              <code>
                  parentElem.insertBefore(elem, null);  <br>
                  // იგივეა რაც <br>
                  parentElem.appendChild(elem);<br>
              </code>


              <h1>კვანძების წაშლა removeChild</h1>

              კვანძის წასაშლელად გამოიყენება ორი მეთოდი :

              <h3>parentElem.removeChild(elem)</h3>

              შლის  elem-ს  parentElem-ის შვილობილების სიიდან.

              <h3>parentElem.replaceChild(newElem, elem)</h3>

              parentElem-ის შვილობილებიდან შლის elem-ს და მის ნაცვლად სვამს newElem-ს.



              <h1>insertAdjacentHTML</h1>

              ეს მეთოდი საშუალებას გვაძლევს დოკუმენტის ნებისმიერ ადგილას ჩავსვათ არა მხოლოდ ერთი ელემენტი ან კვანძი,
              არამედ შედარებით უფრო დოდი html სინტაქსი.  მისი სინტაქსი ასეთია
              <code>
                  object.insertAdjacentHTML(where, html)
              </code>
              ანუ ჯერ ვირჩევთ ობიექტს რომელთან მიმართებაშიც გვინდა, რომ გამოვიყენოთ ეს მეთოდი, შემდეგ ამ ოთხი
              ვარიანტიდან ერთ-ერთს ვუთითებთ პირველ პარამეტრად
              <ul>
                  <li>beforebegin - ობიექტის წინ დამატება</li>
                  <li>afterbegin - ობიექტის ტეგში დამატება დასაწყისიდან</li>
                  <li>beforeend - ობიექტის შემდეგ დამატება</li>
                  <li>afterend - ობიექტის ტეგში დამატება დასასრულის შემდეგ</li>
              </ul>
              <br>
              <img src="images/adjacent.jpg" style="max-width: 500px;display: block; margin:0px auto;"> <br>
              <br>

              ხოლო მეორე პარამეტრად ვუთითებთ იმ html სინტაქსს რომლის დამატებაც გვსურს
              <code>
                  &lt;ul> <br>
                   &nbsp;&nbsp;&nbsp;   &lt;li>1&lt;/li><br>
                   &nbsp;&nbsp;&nbsp;   &lt;li>2&lt;/li><br>
                   &nbsp;&nbsp;&nbsp;   &lt;li>5&lt;/li><br>
                  &lt;/ul><br><br>

                  &lt;script><br>
                  &nbsp;&nbsp;&nbsp;    var ul = document.body.children[0];<br>
                  &nbsp;&nbsp;&nbsp;    var li5 = ul.children[2];<br><br>

                  &nbsp;&nbsp;&nbsp;    li5.insertAdjacentHTML("beforeBegin", "&lt;li>3&lt;/li>&lt;li>4&lt;/li>");<br>
                  &lt;/script>
              </code>

              <h1>append/prepend, before/after, replaceWith</h1>

              გარდა ზემოთ ნახსენები მეთოდებისა, არსებობს კვანძების ჩამატების სხვა ვარიანტებიც:
              <ul>
                  <li><strong>node.append(...nodes)</strong> – ამატებს nodes  node-ს ბოლოში</li>
                  <li><strong>node.prepend(...nodes)</strong> – ამატებს nodes node-ს დასაწყისში</li>
                  <li><strong>node.after(...nodes) </strong>– ამატებს nodes node კვანძის შემდეგ</li>
                  <li><strong>node.before(...nodes)</strong> – ამატებს nodes node კვანძის წინ</li>
                  <li><strong>node.replaceWith(...nodes)</strong> – ამატებს nodes  node-ს ნაცვლად</li>
              </ul>






              <h1>ატრიბუტები</h1>
              რომელიმე ელემენტის სტანდარტულ ატრიბუტთან წვდომა ხდება შემდეგნაირად, მაგალითად გვინდა სურათის
              src ატრიბუტის გაგება
              <code>
                   var elem = document.getElementById("image"); <br><br>
                   alert(elem.src);
              </code>
              ან დავუშვათ გვინდა html ფორმის მეთოდის გაგება
              <code>
                   var elem = document.getElementsByTagName("form"); <br><br>
                   alert(elem[0].method);
              </code>

              არის შემთხვევები, როდესაც ატრიბუტის დასახელება ემთხვევა javascript - ის რეზერვირებულ სიტყვებს,
              მაგალითად html label - ის ატრიბუტი for, ამ დროს ატრიბუტზე მიმართვისას მისი დასახელების წინ
              იწერება სიტყვა html
              <code>
                   var elem = document.getElementsById("lab"); <br><br>
                   alert(elem.htmlfor);
              </code>

              გარდა ამისა javascript - ში არის შემდეგი მეთოდები getAttribute() და setAttribute(), პირველი
              მათგანი საშუალებას გვაძლევს გავიგოთ ამა თუ იმ ატრიბუტის მნიშვნელობა, მეორე კი საშუალებას გვაძლევს
              შევცვალოთ ატრიბუტის მნიშვნელობა. setAttribute() - ს პირველ პარამეტრად გადაეცემა ატრიბუტის სახელი
              ხოლო მეორე პარამეტრად გადაეცემა ის მნიშვნელობა რომელიც გვინდა რომ მიიღოს ამ ატრიბუტმა.

              <code>
                  var elem = document.getElementById("image");<br><br>
                  elem.getAttribute("src"); // ატრიბუტის მნიშვნელობის გარკვევა<br><br>
                  elem.setAttribute("src","images/teriyaki.jpg"); // ატრიბუტის მნიშვნელობის შეცვლა <br><br>
              </code>

              რომელიმე ელემენტის ყველა ატრიბუტის სანახავად გამოიყენება attributes მეთოდი, რომელიც აბრუნებს მასივის
              მსგავს ნაკრებს (არამასივს !!!) => შეგვიძლია მასთან მიმართებაში გამოვიყენოთ length
              <code>
                  var elem = document.getElementById("image");<br><br>
                  console.log(elem.attributes[0]);
              </code>

              ამა თუ იმ ელემენტის html შიგთავსის სანახავად/ჩასაწერად გამოიყენება innerHTML თვისება, მისი მეშვეობით
              შეიძლება დავაბრუნოთ ან შევცვალოთ ელემენტის შიგთავსი, innerHTML - ის მსგავსი თვისებაა outerHTML
              უბრალოდ იგი ტეგებიანად აბრუნებს ელემენტს
              <code>
                  var elem = document.getElementsByTagName("h2");<br><br>
                  console.log(elem[0].innerHTML); // Japanese Vegetarian<br><br>
                  console.log(elem[0].outerHTML); // &lt;h2>Japanese Vegetarian&lt;/h2 >
              </code>

              რომელიმე ელემენტის ტექსტური შიგთავსის  სანახავად/ჩასაწერად გამოიყენება textContent თვისება, ვთქვათ
              id = "for_parent" ელემენტი არის შემდეგი
              <code>
                  var elem = document.getElementById("for_parent"); <br><br>
                  alert(elem.textContent);
              </code>
              <strong>elem.textContent აბრუნებს elem ელემენტში არსებული ყველა ტექსტური კვანძის კონკატენაციას.</strong>



              <code>
                  &lt;div><br>
                    &nbsp;&nbsp;&nbsp;   &lt;h1>გამარჯობა  &lt;/h1><br>
                    &nbsp;&nbsp;&nbsp;   &lt;p> გერასიმე ! &lt;/p><br>
                  &lt;/div><br><br>

                  &lt;script><br>
                    &nbsp;&nbsp;&nbsp;  var news = document.body.children[0];<br><br>

                    &nbsp;&nbsp;&nbsp;  // \n  გამარჯობა\n  გერასიმე!\n<br>
                    &nbsp;&nbsp;&nbsp;  alert( news.textContent );<br>
                  &lt;/script>
              </code>

              <strong>რა მნიშვნელობა აქვს ელემენტში შიგთავსის ჩაწერისას innerHTML-ს გამოვიყენებთ თუ  textContent-ს ?
              </strong> განსხვავება შემდეგია :

              <code>
                  var div = document.createElement('div');  <br>
                  document.body.appendChild(div);<br>
                  div.textContent = "&lt;i>hello world&lt;/i>" //  &lt;i>hello world&lt;/i><br>
                  div.innerHTML = "&lt;i>hello world&lt;/i>" // <i>hello world</i>
              </code>
              ანუ innerHTML ამუშავებს html ტეგებს, textContent კი მათ აღიქვამს, როგორც ჩვეულებრივ სიმბოლოებს.


              იმის გასარკვევად აქვს თუ არა რომელიმე ელემენტს ესა თუ ის ატრიბუტი გამოიყენება თვისება
              hasAttribute("attr"), აბრუნებს true/false მნიშვნელობებს
              <code>
                  var elem = document.getElementsByTagName("h2"); <br><br>
                  console.log(elem.hasAttribute("id")); // true/false
              </code>

              რომელიმე ელემენტის ამა თუ იმ ატრიბუტის წასაშლელად გამოიყენება  removeAttribute("attr") თვისება

              <code>
                   var elem = document.getElementById("for_parent");
                   elem.removeAttribute("id");
                   alert(elem.hasAttribute("id"));  // false
              </code>




          </dd>

          <dt>23. ობიექტი DOCUMENT , მისი თვისებები  </dt>
          <dd class='answer'>
              <h2>ფორმებთან მუშაობა</h2>
              იმისათვის, რომ ამა თუ იმ ელემენტთან ვიმუშაოთ ჯერ უნდა მოხდეს მისი ასე ვთქვათ პოვნა, ამორჩევა
              DOM - ში. HTML ფორმის ამორჩევა, ისევე როგორც, სხვა ელემენტებისა, როგორც უკვე ვნახეთ მრავალნაირად
              შეიძლება. ობიექტ document - ს აქვს თვისება სახელად forms , რომელიც აბრუნებს DOM - ში შემავალი
              ფორმების კოლექციას.
              <code>
                  // პირველი ფორმა DOM ში, აირჩა როგორც კოლექციის პირველი ელემენტი<br>
                  var form = document.forms[0];<br><br>
                  // პირველი ფორმა DOM ში, აირჩა სახელის მიხედვით<br>
                  var form = document.forms.my_form;<br><br>
                  // ფორმის მეთოდი<br>
                  alert(form.method);<br><br>
                  var form = document.forms.my_form;<br><br>
                  // აირჩა ტექსტური ველი სახელად my_text_input<br>
                  var txtInput = document.forms.my_form.my_text_input;<br><br>
                  // ველის ტიპის განსაზღვრა<br>
                  alert(txtInput.type);<br><br>
                  // ველის შიგთავსის განსაზღვრა<br>
                  alert(txtInput.value);<br><br>
                  // ფორმის პირველ ელემენტთან წვდომა<br>
                  alert document.form.elements[0].value;<br><br>
              </code>


              <h2>სურათებთან მუშაობა</h2>

              იმისათვის, რომ ამა თუ იმ ელემენტთან ვიმუშაოთ ჯერ უნდა მოხდეს მისი ასე ვთქვათ პოვნა, ამორჩევა
              DOM - ში. HTML სურათის ამორჩევა, ისევე როგორც, სხვა ელემენტებისა, როგორც უკვე ვნახეთ მრავალნაირად
              შეიძლება. ობიექტ document - ს აქვს თვისება სახელად images , რომელიც აბრუნებს DOM - ში შემავალი
              სურათების კოლექციას.
              <code>
                  // პირველი სურათი DOM ში, აირჩა როგორც კოლექციის პირველი ელემენტი<br>
                  var img = document.images[0];<br><br>
                  // სურათის წყაროს განსაზღვრა<br>
                  alert(img.src);<br><br>
              </code>

              <h2>მიმდინარე url</h2>
              <code>
                  console.log(document.URL);
              </code>

              <h2>მიმდინარე დოკუმენტის title</h2>
              <code>
                  console.log(document.title);
              </code>

              <h2>მიმდინარე დოკუმენტში შემავალი ბმულები </h2>
              <code>
                  console.log(document.links); // აბრუნებს ბმულებისა (a) და არეების (area) კოლექციას
              </code>

              <h2>დოკუმენტის ბოლო განახლების დრო და თარიღი</h2>
              <code>
                  console.log(document.lastModified);
              </code>

              <h2>დოკუმენტის ენკოდინგი</h2>
              <code>
                  console.log(document.inputEncoding);
              </code>

          </dd>

          <dt>24. CSS სტილები</dt>
          <dd class='answer'>

              <h2>ელემენტის სტილი, თვისება style</h2>

              თვისება element.style აბრუნებს ობიექტს, რომელიც გამოიყენება ელემენტის სტილთან წვდომისათვის.
              მისი საშუალებით შეგვიძლია შევცვალოთ CSS-თვისებების უმრავლესობა, მაგალითად element.style.width="100px"
              მუშაობს ისე თითქოს ელემენტს ატრიბუტად მითითებული ჰქონდეს style="width:100px". <br>
              <strong>საზომი ერთეულების მითითება აუცილებელია, elem.style.width = 100 - არ იმუშავებს.<br>
              ისეთი css თვისებების ჩაწერისას, რომელთა დასახელებაც შედგება რამდენიმე სიტყვისაგან, იხმარება
              ე.წ camelcase
              </strong>

              <code>
                  background-color  => elem.style.backgroundColor  <br>
                  z-index           => elem.style.zIndex<br>
                  border-left-width => elem.style.borderLeftWidth<br><br>
                  document.body.style.backgroundColor = prompt('background color?', 'green');
              </code>

              <strong>JavaScript-ის ძველ სტანდარტში სიტყვა "float" იყო რეზერვირებული სიტყვა და არ შეიძლებოდა
              მისი ობიექტის თვისების სახელად გამოყენება. ამიტომ იწერება არა elem.style.float, არამედ
              elem.style.cssFloat.</strong>
              იმისათვის რათა გავაუქმოთ მითითებული სტილი, ამ სტილს მნიშვნელობად უნდა მივანიჭოთ ცარიელი სტრიქონი:
              <strong>elem.style.width="".</strong>
              <code>
                  // თუ გავუშვებთ ამ კოდს < body> დაიმალება <br>
                  document.body.style.display = "none";<br><br>

                  setTimeout(function() {<br>
                  document.body.style.display = "";<br>
                  }, 1000);
              </code>

              <strong>თვისება style-ს ვიყენებთ მხოლოდ მაშინ, როდესაც ვერ ხერხდება კლასებთან მუშაობა, მაგალითად
              თუ რომელიმე ელემენტის ფონის ფერი დამოკიდებულია javascript გამოთვლების შედეგზე</strong>



          </dd>

          <dt>25. Javascript მოვლენები (events)</dt>
          <dd class='answer'>
              მოვლენა - ეს არის ბრაუზერის რეაქცია მომხმარებლის ქმედებებზე.<strong>მოვლენას შეიძლება მიემაგროს ე.წ
              დამმუშავებელი (handler)</strong> ანუ ფუნქცია, რომელიც შესრულდება მაშინ , როდესაც ესა თუ ის
              მოვლენა მოხდება. დამმუშავებლის მიმაგრების რამდენიმე ხერხი არსებობს.
              <h1>მოვლენა როგორც HTML ატრიბუტი</h1>
              <code>
                  &lt;input value="Click" <i>onclick="alert('Hello !')"</i> type="button">
              </code>
              <strong>ყურადღება მივაქციოთ იმ ფაქტს, რომ , onclick ატრიბუტის შიგთავსში გამოყენებულია ერთმაგი
              ბრჭყალები, თავად ატრიბუტი კი მოთავსებულია ორმაგ ბრჭყალებში.</strong>

              ზემოთ მოყვანილი მეთოდი გამოიყენება მაშინ, როდესაც  მოვლენის დამმუშავებელს ევალება უმარტივესი
              ოპერაციის ჩატარება, მაგრამ თუ ეს ოპერაცია შედარებით რთულია მაშინ ის უნდა აღიწეროს  ფუნქციაში
              და დამმუშავებელში უნდა მოხდეს მისი გამოძახება.
              <code>
                  &lt;script> <br>
                   &nbsp; function countRabbits() {<br>
                       &nbsp;&nbsp;&nbsp; // ფუნქციის ლოგიკა<br>
                   &nbsp; }<br>
                  &lt;/script ><br>
                  &lt;input type="button" <i>onclick="countRabbits()"</i> value="დათვლა"/>
              </code>

              <h1>მოვლენა როგორც DOM ობიექტის თვისება</h1>
              დამმუშავებლის მიმაგრება შეიძლება DOM ობიექტის თვისების საშუალებით, რომელიც მიიღება წინსართ "on" - ის
              და მოვლენის სახელის გაერთიანებით მაგალითად onclick
              <code>
                  &lt;input id="elem" type="button" value="click" /><br>
                  &lt;script><br>
                      &nbsp;elem.onclick = function() {<br>
                         &nbsp;&nbsp;&nbsp; alert( 'Hello' );<br>
                     &nbsp; };<br>
                  &lt;/script><br>
              </code>


              <h1>ელემენტთან წვდომა, this </h1>

              მოვლენის დამმუშავებელში გამოყენებული სიტყვა this მიუთითებს მიმდინარე ელემენტზე, ანუ იმ ელემენტზე,
              რომელზეც ეს მოვლენაა მიმაგრებული. ეს შეიძლება გამოვიყენოთ მაშინ.
              <code>
                  &lt;button onclick="alert(this.innerHTML)">click< /button>
              </code>

              <h1>addEventListener და removeEventListener</h1>

              დავუშვათ მოხდა ისე, რომ ერთ მოვლენაზე გვინდა რამოდენიმე დამმუშავებლის მიმაგრება, ვთქვათ ასე:
              <code>
                  input.onclick = function() { alert(1); }  <br>
                  // ...<br>
                  input.onclick = function() { alert(2); } // ჩაანაცვლებს, გადაეწერება წინა დამმუშავებელს<br>
              </code>
              ეს ჩანაწერი გამოიწვევს დამმუშავებლების კონფლიქტს. მეთოდები addEventListener და removeEventListener
              საშუალებას გვაძლევენ შევქმნათ ან წავშალოთ იმდენი დამმუშავებელი რამდენიც გვინდა.
              <code>
                  document.getElementById("myBtn").addEventListener("click", myFunction); <br>
                  document.getElementById("myBtn").addEventListener("click", someOtherFunction);
              </code>
              რაც შეეხება removeEventListener-ს :
              <code>
                  elem.addEventListener( "click" , function() {alert('Спасибо!')}); <br>
                  // ....<br>
                  elem.removeEventListener( "click", function() {alert('Спасибо!')});<br>
              </code>
              <strong>ეს ჩანაწერი არ იმუშავებს. უნდა ჩაიწეროს ასე :</strong>
              <code>
                  function handler() { <br>
                  &nbsp;&nbsp;&nbsp; alert( 'Спасибо!' );<br>
                  }<br><br>

                  input.addEventListener("click", handler);<br>
                  // ....<br>
                  input.removeEventListener("click", handler);<br>
              </code>
              <strong>თუ ფუნქცია არ არის სადმე შენახული და უბრალოდ ისეა გადაცემული addEventListener-ში,
              მაშინ removeEventListener-ით მისი წაშლა შეუძლებელია. არ არსებობს მეთოდი, რომელიც საშუალებას მოგვცემს
              წავიკითხოთ addEventListener-ით მითითებული დამმუშავებელი.</strong><br>
              ასე და ამგვარად არსებობს მოვლენის დამმუშავებლის მითითების სამი ვარიანტი:
              <ul>
                  <li>HTML ატრიბუტი - onclick="...".</li>
                  <li>თვისება: elem.onclick = function.</li>
                  <li>addEventListener</li>
              </ul>

          </dd>

          <dt>26. მაუსის მოვლენები</dt>
          <dd class='answer'>

              მაუსის მოვლენები პირობითად შეიძლება დავყოთ ორ - უბრალო და კომპლექსურ ტიპებად.

              <h2>უბრალო ტიპები</h2>

              <ul>
                  <li><strong>mousedown</strong> -  მარცხენა მაუსი დაჭერილია ელემენტზე</li>
                  <li><strong>mouseup</strong> - მაუსი აეშვა ელემენტიდან</li>
                  <li><strong>mouseover</strong> - მაუსი გაჩნდა ელემენტის თავზე</li>
                  <li><strong>mouseout</strong> - მაუსმა დატოვა ელემენტი</li>
                  <li>
                      <strong>mousemove</strong> - ამ მოვლენის გენერირება ხდება ელემენტის თავზე მაუსის
                      ნებისმიერი გამოძრავებისას.
                  </li>
              </ul>

              <h2>კომპლექსური ტიპები</h2>

              <ul>
                  <li>
                      <strong>click</strong> -  mousedown და mouseup მოვლენების ერთობლიობა
                  </li>
                  <li><strong>contextmenu</strong> - ელემენტზე მარჯვენა მაუსის დაჭერა</li>
                  <li><strong>dblclick</strong> - ელემენტზე ორმაგი დაჭერა</li>
              </ul>

              <strong>შეიძლება ითქვას რომ კომპლექსური მოვლენები შედგება მარტივი მოვლენებისაგან და თეორიულად
              შესაძლებელია რომ მათ გარეშეც ვიმუშავოთ, მაგრამ ისინი არსებობენ და ეს კარგია რადგან მათთან მუშაობა
              უფრო მოსახერხებელია.</strong>

              <h2>მოვლენათა დამუშავების თანმიმდევრობა</h2>

              ერთმა ქმედებამ შეიძლება გამოიძახოს რამდენიმე მოვლენა. მაგალითად მაუსის დაჭერა  ჯერ იძახებს
              mousedown-ს, შემდეგ mouseup-ს და ბოლოს click-ს როდესაც მაუსს ხელს ავუშვებთ. ასეთ შემთხვევებში
              მოვლენათა თანმიმდევრობა ფიქსირებულია. ანუ, დამმუშავებლები გამოძახებულ იქნებიან შემდეგი
              თანმიმდევრობით : mousedown → mouseup → click. <br><br>
              <strong>მოვლენების დამუშავება ხდება დამოუკიდებლად. მაგალითად , მაუსის დაჭერისას მოვლენები
              mouseup + click ფიქსირდება ერთდროულად, მაგრამ მათი დამუშავება ხდება თანმიმდევრულად.
              ჯერ სრულდება mouseup, შემდეგ ეშვება click.</strong>

              <h2>ინფორმაციის მიღება ღილაკზე - which</h2>

              მაუსის მოვლენებთან მუშაიბისას ხშირადაა საჭირო გავიგოთ თუ მაუსის რომელ ღილაკთან გვაქვს საქმე.
              <strong>მაუსის კომკრეტული ღილაკის ამოსაცნობად ობიექტ event-ს აქვს თვისება which.</strong>
              მისი შესაძლო მნიშვნელობებია:
              <ul>
                  <li><strong>event.which == 1</strong> - მარცხენა მაუსი</li>
                  <li><strong>event.which == 2</strong> - შუა მაუსი</li>
                  <li><strong>event.which == 3</strong> - მარჯვენა მაუსი</li>
              </ul>

              <h2>oncontextmenu</h2>

              ეს მოვლენა ხდება მარჯვენა მაუსის დაწკაპუნებისას :
              <code>
                  &lt;div>დააწკაპეთ მარჯვენა მაუსი&lt;/div>
                  &lt;button oncontextmenu="alert('right click !');">click here&lt;/button>
              </code>
              ამ ღილაკზე დაჭერისას oncontextmenu-ს დამმუშავებლის, ანუ alert-ის შემდეგ ჩვეულებრივი კონტექსტური
              მენიუ, რომელსაც ბრაუზერი ყოველდვის აჩენს მარჯვენა მაუსის დაჭერისას. თუ არ გვსურს ამ მენიუს გამოჩენა
              მაშინ ვიქცევით ასე :
              <code>
                  &lt;button oncontextmenu="alert('right click !');return false">click here&lt;/button>
              </code>

              <h2>მოდიფიკატორები shift, alt, ctrl </h2>

              მოდიფიკატორები shift, alt, და ctrl გამოიყენება იმის დასადგენად, მაუსის მოვლენის დროს დაჭერილი
              იყო თუ არა კლავიატურის შესაბამის კლავიშებზე, მაგრამ მანამ მათი გამოყენების ხერხებს გავეცნობით
              გავაკეთოთ პატარა შესავალი.

              <h3>მოვლენა როგორც ობიექტი</h3>

              <strong><label>როგორც ვიცით მოვლენის დამმუშავებელი(handler) არის ფუნქცია, რომელშიც აღწერილია
              ის ინსტრუქცია რომელიც უნდა შესრულდეს მოვლენის მოხდენისას. თუ მოვლენას განვიხილავთ როგორც
              ობიექტს ბუნებრივია მივალთ იმ დასკვნამდე, რომ მას აქვს თავისი თვისებები და მეთოდები. ტექსტური
              ველის მაგალითზე ნაბიჯ-ნაბიჯ აღვწეროთ თუ როგორ და რაში შეიძლება მოვლენის ობიექტის თვისებები,
              ვთქვათ გვინდა დავადგინოთ onclick მოვლენისას დაჭერილი იყო თუ არა  shif ღილაკზე.</label></strong>
              <code>
                  &lt;input type="text" id="inp"> <br><br>

                  &lt;script><br>
                   &nbsp;&nbsp;&nbsp;     var obj = document.getElementById('inp');<br>
                   &nbsp;&nbsp;&nbsp;     obj.onclick = function(<label>e</label>) {<br>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         alert(e.shiftKey);<br>
                   &nbsp;&nbsp;&nbsp;     }<br>
                  &lt; /script>
              </code>
              <strong><label>ფუნქციაში მითითებულ პარამეტრ "e"-ში მოთავსებულია მოვლენის ობიექტი, (პარამეტრის
              ეს სახელი პირობითია, შეგვიძლია დავარქვათ რაც გვინდა), ამ პარამეტრთან მიმართვით ჩვენ მივმართავთ
              მოვლენის ობიექტს. e.shiftKey ჩანაწერი კი არის ამ ობიექტის ერთ-ერთი თვისება, რომელიც აბრუნებს true-ს
              თუ onclick მოვლენისას shift კლავიშზე იყო დაჭერილი და false-ს წინააღმდეგ შემთხვევაში.
              </label></strong>
              ანალოგიურად ხდება alt და ctrl კლავიებზეც.




              მაუსის მოვლენის დროს შეიძლება დაფიქსირდეს პარალელურად დაჭერილი იყო თუ არა კლავიატურის ამა
              თუ იმ კლავიშ-მოდიფიკატორზე. შესაბამისი თვისებებია :

              <ul>
                  <li>
                      shiftKey - აბრუნებს Boolean მნიშვნელობას იმის მიხედვით დაჭერილი იყო თუ არა
                      "SHIFT" კლავიშზე მაუსის მოვლენის დროს.
                  </li>
                  <li>
                      altKey - აბრუნებს Boolean მნიშვნელობას იმის მიხედვით დაჭერილი იყო თუ არა
                      "ALT" კლავიშზე მაუსის მოვლენის დროს.
                  </li>
                  <li>
                      ctrlKey - აბრუნებს Boolean მნიშვნელობას იმის მიხედვით დაჭერილი იყო თუ არა
                      "Ctrl" კლავიშზე მაუსის მოვლენის დროს.
                  </li>
              </ul>

              მაგალითად ეს ღილაკი იმუშავებს მხოლოდ Alt+Shift შემთხვევაში:

              <code>
                  &lt;button> Alt+Shift+click ! &lt;/button> <br> <br>

                  &lt;script> <br>
                     document.body.children[0].onclick = function(e) { <br>
                      &nbsp;&nbsp;&nbsp;   if (!e.altKey || !e.shiftKey) return; <br>
                      &nbsp;&nbsp;&nbsp;   alert('Hello !'); <br>
                     } <br>
                  &lt;/script>
              </code>


              <h2>კურსორის კოორდინატები : clientX/Y , pageX/Y</h2>

              მაუსის ყველა მოვლენისას კურსორის კოორდინატები განიხილება ორნაირად : კოორდინატები ფანჯრის მიმართ
              და კოორდინატები დოკუმენტის მიმართ. თვისებების წყვილი <strong>clientX/clientY</strong> შეიცავს
              კურსორის კოორდინატებს მიმდინარე ფანჯარასთან მიმართებაში. მაგალითად თუ ფანჯრის ზომებია 500X500
              და კურსორი მიტანილია ფანჯრის ცენტრში clientX და clientY იქნება 250-ის ტოლი, და რა ზემოქმედებაც
              არ უნდა მოვახდინოთ  უშუალოდ გვერდზე ანუ დოკუმენტზე, თუ მაუსს არ გავანძრევთ ეს კოორდინატები
              არ შეიცვლება.
              <code>
                  &lt;input onmousemove="this.value = event.clientX+':'+event.clientY">
              </code>
              დოკუმენტთან მიმართებაში კურსორის კოორდინატების დასადგენად გამოიყენება <strong>pageX/pageY</strong>
              თვისებების წყვილი. ეს თვისებები კოორდინატებს თვლიან დოკუმენტის მარცხენა ზედა კუთხესთან მიმართებაში.




              <h2>mouseover და mouseout</h2>

              მოვლენა mouseover ხდება მაშინ როდესაც მაუსი აღმოჩნდება ელემენტის თავზე,  mouseout კი ხდება მაშინ,
              როდესაც მაუსი ტოვებს ელემენტს.  <br><br>
              <img src="images/over.png" style="max-width: 500px;display: block; margin:0px auto;"> <br><br>

              <h2>mouseenter და mouseleave</h2>

              mouseenter/mouseleave მოვლენები გვანან mouseover/mouseout-ს. ეს მოვლენებიც მაშინ ხდება, როდესაც
              კურსორი მიდის ელემენტთან და ტოვებს მას, მაგრამ არის განსხვავებაც: mouseover/mouseout შემთხვევაში
              გვაქვს ასეთი სურათი

              <br><br>
              <img src="images/mouseover-to-child.png" style="max-width: 500px;display: block; margin:0px auto;">
              <br><br>

              ანუ როდესაც რომელიღაც A ელემენტზე მივიტანთ მაუსს დაფიქსირდება mouseover, მაგრამ თუ მის შვილობილ
              რომელიმე B ელემენტზე მივიტანთ,  უკვე B-ს მიმართ დაფიქსირდება mouseover, ხოლო A-ს მიმართ
              დაფიქსირდება mouseout (იგივე ხდება შვილობილიდან მშობელზე გადასვლისასაც) <strong>
              mouseenter/mouseleave და mouseover/mouseout მოვლენებს შორის განსხვავებაც ესაა -
              mouseenter/mouseleave - ის შემთხვევაში ეს მემკვიდრეობითობა არ მოქმედებს. ანუ მიდის ელემენტთან –
              ხდება mouseenter, მერე კი, მიუხედავად იმისა, ელემენტის შეგნით ის სად გადაადგილდება
              როდესაც კურსორი დატოვებს ელემენტს მხოლოდ მაშინ მოხდება mouseleave.</strong>

          </dd>

          <dt>27. კლავიატურის მოვლენები</dt>
          <dd class='answer'>

              <h2>keydown, keyup</h2>

              მოვლენები keydown/keyup ხდება კლავიატურის რომელიმე კლავიშზე დაჭერა/აშვებისას. ამ <label>მოვლენის
              ობიექტს</label> აქვს თვისება keyCode, რომლის დახმარებითაც შეგვიძლია გავიგოთ  კლავიშის კოდი.
              კლავიშის კოდი ერთიდაიგივეა რეგისტრისა და კონკრეტულ მომენტში კლავიატურაზე დაყენებული ენის
              მიუხედავად. მაგალითად კლავიში z შეიძლება აღნიშნავდეს : "z", "Z" ან "ზ" -ს თუ ქართული ენა გვაქვს
              მითითებული, მაგრამ მისი სკან-კოდი არ იცვლება და არის 90. მაგალითად ტექსტურ ველში "z" კლავიშის
              დაჭერისას დავაბრუნოთ ამ კლავიშის კოდი:
              <code>
                  &lt;input type="text" id="inp"> <br><br>

                  &lt;script><br>
                   &nbsp;&nbsp;&nbsp; var obj = document.getElementById('inp');<br>
                   &nbsp;&nbsp;&nbsp;obj.onkeydown = function(<label>e</label>) {<br>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(e.keyCode); // ზ=90, z=90, Z=90<br>
                   &nbsp;&nbsp;&nbsp;}<br>
                  &lt;/script>

              </code>
              keydown/keyup მოვლენის ობიექტს აქვს აგრეთვე shiftKey, altKey, ctrlKey, რომლებიც უკვე განხილული
              მაუსის მოვლენების ანალოგიურად მუშაობენ და ამიტომ აქ აღარ განვიხილავთ.

              <h2>keypress</h2>

              მოვლენა keypress ფიქსირდება keydown მოვლენის მოხდენისთანავე, ანუ keypress არის keydown-ის
              "გაგრძელება". keypress მოვლენა ახდენს <strong>მხოლოდ  ციფრული და სიმბოლური კლავიშების გენერირებას.
              სამართავ კლავიშებს, ისეთებს როგორებიცაა Ctrl, Shift, F1, F2… keypress არ აღიქვამს. </strong>
              <strong>keypress მოვლენა საშუალებას გვაძლევს მივიღოთ <label>სიმბოლოს კოდი.</label></strong>
              keydown-ისაგან განსხვავებით keypress-ისთვის "ზ", "z" და "Z" სხვადასხვა სიმბოლოებია. სიმბოლოების
              კოდები ინახება თვისებებში charCode და which.

              <code>
                  &lt;input type="text" id="inp"> <br><br>

                  &lt;script><br>
                   &nbsp;&nbsp;&nbsp; var obj = document.getElementById('inp');<br>
                   &nbsp;&nbsp;&nbsp;obj.onkeypress= function(<label>e</label>) {<br>
                   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(e.keyCode); // ზ=4310, z=122, Z=90<br>
                   &nbsp;&nbsp;&nbsp;}<br>
                  &lt;/script>

              </code><br><br>
              თუ გვსურს, რომ მომხმარებელს დავუბლოკოთ ტექსტურ ველში ტექსტის აკრეფის შესაძლებლობა უნდა მოვიქცეთ
              ასე :
              <code>
                  &lt;input onkeydown="return false" type="text" size="30"> <br>
                  &lt;input onkeypress="return false" type="text" size="30">
              </code> <br> <br>


          </dd>

          <dt>28. დოკუმენტის მოვლენები</dt>
          <dd class='answer'>

              HTML დოკუმენტის ჩატვირთვის პროცესი პირობითად შეიძლება დაიყოს სამ ნაწილად :
              <ul>
                  <li>
                      <strong>DOMContentLoaded</strong> - ბრაუზერმა სრულად ჩატვირთა HTML, და გააკეთა DOM-ხე.
                  </li>
                  <li><strong>load</strong> - ბრაუზერმა ჩატვირთა ყველა რესურსი.</li>
                  <li><strong>beforeunload/unload</strong> - გვერდიდან გასვლა.</li>
              </ul>
              ყველა მათგანთან შეიძლება დავაკავშიროთ დამმუშავებლები და ამის საშაუალებით ჩავატაროთ სხვადასხვბა
              ოპერაციები :
              <ul>
                  <li>
                      <strong>DOMContentLoaded</strong> - ყველა DOM-ელემენტი უკვე შექმნილია, შეიძლება მათი ძებნა,
                      შეიძლება ინტერფეისის შექმნა, მაგრამ არაა გამორიცხული ამ დროს ჯერ კიდევ არ იყოს ჩატვირთული
                      რომელიმე სურათი ან რომელიმე CSS სტილი.
                  </li>
                  <li>
                      <strong>load</strong> - გვერდი თავისი ყველა რესურსით უკვე ჩატვირთულია, გამოიყენება იშვიათად,
                      როგორც წესი არაა ხოლმე ამ მომენტის დალოდება საჭირო.</li>
                  <li>
                      <strong>beforeunload/unload</strong> - შეიძლება შემოწმდეს შეინახა თუ არა მომხმარებელმა
                      ცვლილებები, დაზუსტდეს ნამდვილად სურს თუ არა გვერდის დატოვება მას და ა.შ
                  </li>
              </ul>


              <h2>DOMContentLoaded</h2>

              ამ მოვლენის მისი დამმუშავებლის მიმაგრება შესაძლებელია მხოლოდ addEventListener-ის საშუალებით:
              <code>
                  &lt;script>  <br><br>
                  &nbsp;&nbsp;&nbsp;    function ready() {<br>
                      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    alert( 'DOM created' );<br>
                      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    alert( "Image sizes: " + img.offsetWidth + "x" + img.offsetHeight );<br>
                  &nbsp;&nbsp;&nbsp;    }<br><br>

                  &nbsp;&nbsp;&nbsp;    document.addEventListener("DOMContentLoaded", ready);<br>
                  &lt;/script><br><br>

                  &lt;img id="img" src="images/image.jpg">
              </code>

              ამ მაგალითში DOMContentLoaded მოვლენის დამმუშავებელი ready ფუნქცია შესრულდება დოკუმენტის
              ჩატვირთვისთანავე ისე რომ არც დაელოდება სურათის ჩათვირთვას და ამიტომ მეორე alert-ში ამოვარდება
              "0x0" რადგან მეორე alert-ის დროს სურათი ჯერ კიდევ მიუწვდომელი იქნება.

              <h2>window.onload</h2>

              მოვლენა onload ფიქსირდება მაშინ, როდესაც ჩაიტვირთება მთლიანი გვერდი რესურსების ჩათვლით – სტილი,
              სურათები, სკრიპტები და ა.შ. ქვემოთ მოყვანილ მაგალითში alert მოხდება მხოლოდ მაშინ როდესაც ჩაიტვირთება
              ყველაფერი  IFRAME და სურათის ჩათვლით:
              <code>
                   &lt;script><br>
                    &nbsp;&nbsp;&nbsp;      window.onload = function() {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;          alert( 'Документ и все ресурсы загружены' );<br>
                    &nbsp;&nbsp;&nbsp;      };<br>
                   &lt;/script><br>
                   &lt;iframe src="https://example.com/" style="height:60px">< /iframe><br>
                   &lt;img src="images/image.jpg">
              </code>

              <h2>indow.onunload</h2>

              ეს მოვლენა ფიქსირდება მაშინ, როდესაც მომხმარებელი გადის გვერდიდან ან ხურავს მას.

              <h2>indow.onbeforeunload</h2>

              ეს მოვლენა ფიქსირდება მაშინ თუ მომხმარებელმა დააპირა სხვა გვერდზე გადასვლა ან დააჭირა ღილაკს
              «ფანჯრის დახურვა»,  onbeforeunload-ის დამმუშავებელმა შეიძლება შეაჩეროს ეს პროცესი და გააკეთოს
              გაფრთხილება. მაგალითად:
              <code>
                  window.onbeforeunload = function() {  <br>
                   &nbsp;&nbsp;&nbsp;   return "ნამდვილად გსურთ გასვლა ?"; <br>
                  };
              </code>

          </dd>

          <dt>29. ფორმის მოვლენები</dt>
          <dd class='answer'>

              <h1>ნავიგაცია ფორმის ელემენტებში</h1>

              <h2>ფსევდომასივი form.elements</h2>

              FORM-ის ელემენტებთან წვდომა შეიძლება დავამყაროთ მათი სახელებით ან ნომრებით, ამისათვის გამოიყენება
              თვისება document.forms[name/index]. მაგალითად:
              <code>
                  document.forms.my -- ფორმა სახელით 'my'. <br>
                  document.forms[0] -- პირველი ფორმა დოკუმენტში.
              </code>
              <strong>ანალოგიურად შეიძლება მივიღოთ ფორმის ნებისმიერი ელემენტი  form.elements მეთოდის გამოყენებით.
              </strong> <br><br><img src="images/form.png" style="max-width: 500px;display: block; margin:0px auto;">
              <br><br>
              <code>
                  &lt;form name="my"><br>
                    &nbsp;&nbsp; &lt;input name="one" value="1"><br>
                    &nbsp;&nbsp; &lt;input name="two" value="2"><br>
                  &lt;/form><br><br>

                  &lt;script><br>
                    &nbsp;&nbsp;&nbsp;var form = document.forms.my; // იგივეა რაც document.forms[0]<br><br>

                    &nbsp;&nbsp;&nbsp;var elem = form.elements.one; // იგივეა რაც form.elements[0]<br><br>

                    &nbsp;&nbsp;&nbsp;alert( elem.value ); // 1<br>
                  &lt;/script>
              </code>

              <strong>შეიძლება მოხდეს ისე, რომ რამოდენიმე ელემენტს ჰქონდეს ერთი სახელი. ასეთ შემთხვევაში
              form.elements[name] აბრუნებს ელემენტების კოლექციას, მაგალითად:</strong>
              <code>
                  &lt;form><br>
                   &nbsp;&nbsp;   &lt;input type="radio" name="age" value="10"><br>
                   &nbsp;&nbsp;   &lt;input type="radio" name="age" value="20"><br>
                  &lt;/form><br><br>

                  &lt;script><br>
                  &nbsp;&nbsp;&nbsp;  var form = document.forms[0];<br><br>

                  &nbsp;&nbsp;&nbsp;  var elems = form.elements.age;<br><br>

                  &nbsp;&nbsp;&nbsp;  alert(elems[0].value); // 10, первый input<br>
                  &lt;/script>
              </code>

              <h2>ბმული ფორმაზე element.form</h2>

              თვისება element.form-ის საშუალებით შეიძლება დავადგინოთ კონკრეტული ელემენტის ფორმა, ანუ მისი
              მშობელი ფორმა:
              <code>

                  &lt;form><br>
                  &nbsp;&nbsp;   &lt;input type="text" name="surname"><br>
                  &lt;/form><br><br>

                  &lt;script><br>
                   &nbsp;&nbsp;&nbsp;  var form = document.forms[0];<br><br>

                   &nbsp;&nbsp;&nbsp; var elem = form.elements.surname;<br><br>

                   &nbsp;&nbsp;&nbsp;  alert(elem.form == form); // true<br>
                  &lt;/script>
                  </code>

              <h2>ელემენტი label</h2>

              ელემენტი label არის ერთ-ერთი მნიშვნელოვანი რამ როდესაც ფორმებზე ვსაუბრობთ.<strong>
              label-ზე მაუსის დაჭერა ითვლება როგორც ფოკუსირება ან დაჭერა ფორმის იმ ელემენტზე, რომელზე
              მიბმულიცაა იგი.</strong> ეს მომხმარებელს საშუალებას აძლევს მაუსი დააწკაპუნოს, არა პატარა კვადრატზე
              რომელსაც input type=checkbox (radio) გვაძლევს, არამედ დიდ და ლამაზ ნიშნულზე. იმის მისათითებლად
              თუ რომელ ელემენტზეა მიმაგრებული label, არსებობს ორი გზა: მივცეთ label-ს ატრიბუტი for:
              <code>
                  &lt;table><br>
                      &nbsp;&nbsp;&lt;tr><br>
                        &nbsp;&nbsp;&nbsp;&nbsp; &lt;td><br>
                          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label for="agree">I egree&lt;/label><br>
                         &nbsp;&nbsp;&nbsp;&nbsp; &lt;/td><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;  &lt;td><br>
                          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input id="agree" type="checkbox"><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;  &lt;/td><br>
                      &nbsp;&nbsp;&lt;/tr><br>
                      &nbsp;&nbsp;&lt;tr><br>
                         &nbsp;&nbsp;&nbsp;&nbsp; &lt;td><br>
                          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;label for="not-a-robot">I'm not robot&lt;/label><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;  &lt;/td><br>
                         &nbsp;&nbsp;&nbsp;&nbsp; &lt;td><br>
                          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input id="not-a-robot" type="checkbox"><br>
                       &nbsp;&nbsp;&nbsp;&nbsp;  &lt;/td><br>
                      &nbsp;&nbsp;&lt;/tr><br>
                  &lt;/table>
              </code>

              და მეორე გზაა მოვათავსოთ ელემენტი label-ში:
              <code>
                  &lt;label> click me &lt;input type="checkbox">&lt;/label>
              </code>


              <h2>ელემენტები input და textarea</h2>

              input ტიპების უმრავლესობის მნიშვნელობების მინიჭება/წაკითხვა ხდება  value თვისების გამოყენებით:
              <code>
                  input.value = "ახალი მნიშვნელობა"; <br>
                  textarea.value = "ახალი ტექსტი";
              </code>
              გამონაკლისია  – input type="checkbox" და input type="radio". <strong>მიმდინარე «მონიშნული»
              მდგომარეობა checkbox და radio-სათვის განისაზღვრება თვისებაში  checked (true/false):</strong>
              <strong>
                  if (input.checked) {<br>
                    &nbsp;&nbsp;&nbsp;alert( "არჩეულია" );<br>
                  }
              </strong>

              <h2>მოვლენები focus და blur</h2>

              მოვლენა focus ფიქსირდება მაშინ, როდესაც მომხმარებელი ახდენს ფოკუსირებას ელემენტზე, მაგალითად
              აწვება მას მაუსით.  blur მოვლენა კი ფიქსირდება მაშინ, როდესაც ელემენტი კარგავს ფოკუსს, მაგალითად
              როცა მაუსი აწვება ეკრანის სხვა ადგილას, ელემენტის გარეთ. <br><br>
              <img src="images/focus.jpg" style="max-width: 900px;display: block; margin:0px auto;"> <br><br>
              ამ მაგალითში onblur-ის  დამმუშავებელი ამოწმებს, რომ ველში მხოლოდ რიცხვითი მნიშვნელობაა შეყვანილი,
              თუ არადა აჩვენებს შეცდომას. onfocus-ის დამმუშავებელი კი ამოწმებს თუ შესატანი ველის მიმდინარე
              მდგომარეობა შეცდომაა უბრუნებს მას პირვანდელ სახეს რათა მერე თავიდან მოხდეს გადამოწმება.

              <h2>მოვლენა change</h2>

              მოვლენა change ფიქსირდება ფორმის ელემენტის მნიშვნელობის შეცვლის პროცესის დასრულებისას, ანუ მაშინ
              როდესაც ხდება ელემენტის მნიშვნელობის დაფიქსირება. ტექსტური ელემენტების შემთხვევაში ეს მოვლენა
              ხდება მაშინ როდესაც ისინი ფოკუსს კარგავენ.
              <code>
                  &lt;input type="text" onchange="alert(this.value)">
              </code>
              დანარჩენი ელემენტებისათვის: select, input type=checkbox/radio, ეს მოვლენა დგება მათი მნიშვნელობის
              შეცვლისთანავე.

              <h2>მოვლენა input</h2>

              მოვლენა input ფიქსირდება ტექსტური ველის მნიშვნელობის შეცვლისთანავე, ანუ უხეშად რომ ვთქვათ ეს
              მოვლენა მუშაობს "live" რეჟიმში.
              <code>
                  &lt;input type="text"> oninput: &lt;span id="result">&lt;/span> <br>
                  &lt;script><br>
                   &nbsp;   var input = document.body.children[0];<br>

                    &nbsp;&nbsp;  input.oninput = function() {<br>
                      &nbsp;&nbsp;&nbsp;&nbsp;    document.getElementById('result').innerHTML = input.value;<br>
                   &nbsp;   };<br>
                  &lt;/script>
              </code>

              <h1>ფორმა : გაგზავნა, მოვლენა  submit</h1>

              <h2>მოვლენა submit</h2>

              მოვლენა submit ფიქსირდება ფორმის  გაგზავნისას. ფორმის გასაგზავნად მომხმარებელს აქვს ორი ვარიანტი:
              <ul>
                  <li>
                      <strong>
                          პირველი – დაჭიროს ღილაკს &lt;input type="submit"> ან &lt;input type="image">.
                      </strong>
                  </li>
                  <li>
                      <strong>
                          მეორე – დააჭიროს Enter-ს, ამა თუ იმ ველში ყოფნისას.
                      </strong>
                  </li>
              </ul>

              ორივე შემთხვევაში ფიქსირდება მოვლენა submit. შესაძლებელია მოვლენის დამმუშავებელში შემოწმდეს ინფორმაცია
              და თუ იგი არასწორია, გამოვიდეს შეცდომა და  მოხდეს event.preventDefault() - ანუ მოვლენის გაუქმება.


          </dd>


      </dl>

  </div>
  <!-- თეორიის დასასრული!-->

  <br><br><br>



  <br><br><br>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
  <script type="text/javascript">
      $(".faqs dd").hide();
      $(".faqs dt").click(function () {
          $(this).next(".faqs dd").slideToggle(500);
          $(this).toggleClass("expanded");
      });
  </script>

</body>
</html>
